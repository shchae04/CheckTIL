# 웹사이트 접근 과정: 백엔드 관점에서의 이해

웹사이트에 접근할 때 발생하는 과정을 백엔드 관점에서 상세히 설명합니다. 이 문서는 OSI 7계층 모델을 기반으로 네트워크 통신 과정과 서버 측 처리에 중점을 둡니다.

## 목차
1. [OSI 7계층 모델 개요](#1-osi-7계층-모델-개요)
2. [도메인 이름 해석 (DNS)](#2-도메인-이름-해석-dns)
3. [TCP 연결 수립 (3-Way Handshake)](#3-tcp-연결-수립-3-way-handshake)
4. [HTTP 요청과 응답](#4-http-요청과-응답)
5. [서버 측 처리 과정](#5-서버-측-처리-과정)
6. [TCP 연결 종료 (4-Way Handshake)](#6-tcp-연결-종료-4-way-handshake)
7. [데이터 전송 과정에서의 계층별 역할](#7-데이터-전송-과정에서의-계층별-역할)
8. [성능 최적화 기법](#8-성능-최적화-기법)
9. [보안 고려사항](#9-보안-고려사항)

## 1. OSI 7계층 모델 개요

OSI(Open Systems Interconnection) 모델은 네트워크 통신을 7개의 계층으로 나누어 설명하는 개념적 모델입니다.

### 계층별 역할과 프로토콜

| 계층 | 이름 | 주요 역할 | 대표 프로토콜/기술 | 데이터 단위 |
|------|------|-----------|-------------------|------------|
| 7 | 응용 계층<br>(Application) | 사용자와 네트워크 간 인터페이스 제공 | HTTP, SMTP, FTP, DNS | 데이터(Data) |
| 6 | 표현 계층<br>(Presentation) | 데이터 형식 변환, 암호화/복호화 | SSL/TLS, JPEG, MPEG | 데이터(Data) |
| 5 | 세션 계층<br>(Session) | 통신 세션 관리 | NetBIOS, RPC | 데이터(Data) |
| 4 | 전송 계층<br>(Transport) | 종단간 통신 제어, 신뢰성 보장 | TCP, UDP | 세그먼트(Segment) |
| 3 | 네트워크 계층<br>(Network) | 패킷 라우팅, 논리적 주소 지정 | IP, ICMP, OSPF | 패킷(Packet) |
| 2 | 데이터 링크 계층<br>(Data Link) | 물리적 주소 지정, 오류 감지 | Ethernet, PPP, ARP | 프레임(Frame) |
| 1 | 물리 계층<br>(Physical) | 비트 전송, 물리적 연결 | 이더넷 케이블, 광섬유, 무선 | 비트(Bit) |

### TCP/IP 모델과의 비교

OSI 모델이 7계층으로 구분되는 반면, 실제 인터넷에서 주로 사용되는 TCP/IP 모델은 4계층으로 구성됩니다:

```
OSI 모델                TCP/IP 모델
---------              -----------
응용 계층 (7)  ┐
표현 계층 (6)  ├─→ 응용 계층
세션 계층 (5)  ┘
전송 계층 (4)  ───→ 전송 계층
네트워크 계층 (3) ───→ 인터넷 계층
데이터 링크 계층 (2) ┐
물리 계층 (1)      ┘─→ 네트워크 접근 계층
```

## 2. 도메인 이름 해석 (DNS)

사용자가 웹 브라우저에 URL(예: www.google.com)을 입력하면, 가장 먼저 이 도메인 이름을 IP 주소로 변환하는 과정이 필요합니다.

### DNS 조회 과정 (백엔드 관점)

1. **DNS 쿼리 생성**: 브라우저는 운영체제의 DNS 리졸버에 도메인 이름 해석을 요청합니다.
2. **DNS 패킷 구성**: 
   - 응용 계층(7계층): DNS 프로토콜로 쿼리 메시지 생성
   - 전송 계층(4계층): UDP를 사용하여 DNS 쿼리를 포장 (일반적으로 포트 53 사용)
   - 네트워크 계층(3계층): IP 헤더 추가 (목적지는 DNS 서버 IP)
   - 데이터 링크 계층(2계층): 이더넷 프레임으로 포장
   - 물리 계층(1계층): 비트로 변환하여 전송

3. **DNS 서버 처리**:
   - 로컬 DNS 서버는 쿼리를 수신하고 캐시를 확인
   - 캐시에 없는 경우, 루트 DNS 서버부터 시작하여 재귀적 또는 반복적 쿼리 수행
   - 최종적으로 권한 있는 DNS 서버가 IP 주소 반환

4. **DNS 응답 처리**:
   - DNS 서버는 도메인 이름에 대한 IP 주소를 포함한 응답 생성
   - 응답은 요청과 동일한 계층을 거쳐 클라이언트에게 전달

### DNS 패킷 구조

```
+---------------------+
| DNS 헤더            |
| - 트랜잭션 ID       |
| - 플래그            |
| - 질문 수           |
| - 응답 레코드 수     |
+---------------------+
| 질문 섹션           |
| - 도메인 이름       |
| - 쿼리 유형         |
| - 쿼리 클래스       |
+---------------------+
| 응답 섹션           |
| - 레코드 데이터      |
+---------------------+
```

## 3. TCP 연결 수립 (3-Way Handshake)

IP 주소를 획득한 후, 브라우저는 웹 서버와 TCP 연결을 수립합니다. 이 과정은 전송 계층(4계층)에서 이루어집니다.

### 3-Way Handshake 과정

```
클라이언트                                           서버
    |                                                |
    |------------------ SYN (seq=x) --------------->|
    |                                                |
    |<-------- SYN-ACK (seq=y, ack=x+1) ------------|
    |                                                |
    |----------------- ACK (ack=y+1) -------------->|
    |                                                |
    |                연결 설정 완료                   |
    |                                                |
```

1. **SYN (Synchronize)**:
   - 클라이언트는 초기 시퀀스 번호(ISN)를 포함한 SYN 패킷 전송
   - TCP 헤더의 SYN 플래그 = 1

2. **SYN-ACK (Synchronize-Acknowledge)**:
   - 서버는 자신의 ISN과 클라이언트 ISN+1을 ACK 번호로 포함한 SYN-ACK 패킷 응답
   - TCP 헤더의 SYN 플래그 = 1, ACK 플래그 = 1

3. **ACK (Acknowledge)**:
   - 클라이언트는 서버의 ISN+1을 ACK 번호로 포함한 ACK 패킷 전송
   - TCP 헤더의 ACK 플래그 = 1

### TCP 패킷 구조

```
+---------------------+
| TCP 헤더            |
| - 출발지 포트        |
| - 목적지 포트        |
| - 시퀀스 번호        |
| - 확인 응답 번호     |
| - 헤더 길이         |
| - 플래그 (SYN/ACK)  |
| - 윈도우 크기       |
| - 체크섬            |
| - 긴급 포인터       |
| - 옵션              |
+---------------------+
| 데이터              |
+---------------------+
```

## 4. HTTP 요청과 응답

TCP 연결이 수립되면, 브라우저는 HTTP 요청을 생성하여 서버에 전송합니다. 이 과정은 응용 계층(7계층)에서 이루어집니다.

### HTTP 요청 과정

1. **HTTP 요청 메시지 생성**:
   - 요청 라인: 메서드(GET, POST 등), URI, HTTP 버전
   - 헤더: Host, User-Agent, Accept 등
   - 본문(필요한 경우): POST 요청의 데이터 등

2. **계층별 처리**:
   - 응용 계층(7계층): HTTP 요청 메시지 생성
   - 전송 계층(4계층): TCP 세그먼트로 포장 (일반적으로 포트 80 또는 443 사용)
   - 네트워크 계층(3계층): IP 패킷으로 포장
   - 데이터 링크 계층(2계층): 이더넷 프레임으로 포장
   - 물리 계층(1계층): 비트로 변환하여 전송

### HTTP 응답 과정

1. **서버의 HTTP 응답 생성**:
   - 상태 라인: HTTP 버전, 상태 코드, 상태 메시지
   - 헤더: Content-Type, Content-Length, Server 등
   - 본문: HTML, JSON 등의 응답 데이터

2. **계층별 처리**:
   - 응용 계층에서 생성된 HTTP 응답은 요청과 동일한 계층을 거쳐 클라이언트에게 전달

### HTTP 메시지 구조

```
요청 메시지:
-------------
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

[요청 본문]

응답 메시지:
-------------
HTTP/1.1 200 OK
Date: Mon, 23 May 2023 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 138

[응답 본문 - HTML 등]
```

## 5. 서버 측 처리 과정

웹 서버가 HTTP 요청을 수신한 후 응답을 생성하기까지의 백엔드 처리 과정을 설명합니다.

### 웹 서버 아키텍처

```
클라이언트 요청 → 웹 서버(Nginx/Apache) → 애플리케이션 서버 → 데이터베이스
                                      ↓
                                  정적 파일
```

### 요청 처리 단계

1. **요청 수신 및 파싱**:
   - 웹 서버는 TCP 소켓으로부터 HTTP 요청을 읽음
   - HTTP 헤더와 본문을 파싱하여 요청 정보 추출

2. **요청 라우팅**:
   - URL 경로에 따라 요청을 적절한 핸들러로 라우팅
   - 정적 파일 요청은 파일 시스템에서 직접 처리
   - 동적 콘텐츠 요청은 애플리케이션 서버로 전달

3. **애플리케이션 로직 실행**:
   - 비즈니스 로직 처리 (인증, 권한 검사, 데이터 처리 등)
   - 필요한 경우 데이터베이스 쿼리 실행
   - 응답 데이터 생성 (HTML, JSON 등)

4. **응답 생성**:
   - HTTP 상태 코드 결정
   - 응답 헤더 설정 (Content-Type, Content-Length 등)
   - 응답 본문 포함

5. **응답 전송**:
   - 생성된 HTTP 응답을 TCP 소켓을 통해 클라이언트에게 전송

### 서버 처리 최적화

- **워커 프로세스/스레드**: 다중 요청 동시 처리
- **이벤트 루프**: 비동기 I/O를 통한 효율적인 리소스 사용
- **캐싱**: 자주 요청되는 데이터 메모리에 저장
- **로드 밸런싱**: 여러 서버에 요청 분산

## 6. TCP 연결 종료 (4-Way Handshake)

HTTP 요청과 응답이 완료되면, TCP 연결을 종료하는 과정이 진행됩니다. 이 과정은 전송 계층(4계층)에서 이루어집니다.

### 4-Way Handshake 과정

```
클라이언트                                           서버
    |                                                |
    |------------------ FIN (seq=m) --------------->|
    |                                                |
    |<------------------ ACK (ack=m+1) -------------|
    |                                                |
    |<------------------ FIN (seq=n) --------------|
    |                                                |
    |------------------ ACK (ack=n+1) ------------->|
    |                                                |
    |                연결 종료 완료                   |
    |                                                |
```

1. **FIN (Finish)**:
   - 연결을 종료하려는 측(일반적으로 클라이언트)이 FIN 패킷 전송
   - TCP 헤더의 FIN 플래그 = 1

2. **ACK**:
   - 상대방(서버)은 FIN에 대한 ACK 패킷으로 응답
   - 이 시점에서 클라이언트→서버 방향의 연결은 종료됨
   - 서버는 여전히 데이터를 클라이언트에게 보낼 수 있음 (Half-Close)

3. **FIN**:
   - 서버가 모든 데이터 전송을 마치면 FIN 패킷 전송
   - TCP 헤더의 FIN 플래그 = 1

4. **ACK**:
   - 클라이언트는 서버의 FIN에 대한 ACK 패킷으로 응답
   - 이 시점에서 양방향 연결이 모두 종료됨

### TIME_WAIT 상태

- 마지막 ACK를 보낸 측(일반적으로 클라이언트)은 일정 시간 동안 TIME_WAIT 상태를 유지
- 목적: 지연된 패킷이 새로운 연결에 영향을 미치는 것을 방지
- 일반적으로 2MSL(Maximum Segment Lifetime) 동안 유지 (약 2분)

## 7. 데이터 전송 과정에서의 계층별 역할

웹사이트 접근 과정에서 각 OSI 계층이 어떻게 데이터를 처리하는지 상세히 설명합니다.

### 데이터 캡슐화 과정 (클라이언트 → 서버)

```
[응용 계층]     HTTP 요청 메시지
    ↓
[표현 계층]     데이터 변환/암호화 (TLS 사용 시)
    ↓
[세션 계층]     세션 관리
    ↓
[전송 계층]     TCP 헤더 추가 (포트 정보 등)
    ↓           ┌─────────────────────┐
                │ TCP 헤더 │ HTTP 데이터 │
                └─────────────────────┘
[네트워크 계층]  IP 헤더 추가 (IP 주소 정보)
    ↓           ┌────────────────────────────┐
                │ IP 헤더 │ TCP 헤더 │ HTTP 데이터 │
                └────────────────────────────┘
[데이터 링크 계층] MAC 헤더/트레일러 추가
    ↓           ┌───────────────────────────────────┐
                │ MAC 헤더 │ IP 헤더 │ TCP 헤더 │ HTTP 데이터 │ FCS │
                └───────────────────────────────────┘
[물리 계층]     비트로 변환하여 전송 매체로 전송
```

### 데이터 역캡슐화 과정 (서버 → 클라이언트)

서버에서는 위 과정의 역순으로 데이터를 처리합니다:

1. **물리 계층**: 비트 스트림 수신
2. **데이터 링크 계층**: MAC 주소 확인, 프레임 검증
3. **네트워크 계층**: IP 주소 확인, 패킷 라우팅
4. **전송 계층**: 포트 번호 확인, 세그먼트 재조립
5. **세션 계층**: 세션 관리
6. **표현 계층**: 데이터 형식 변환/복호화
7. **응용 계층**: HTTP 요청 처리

## 8. 성능 최적화 기법

백엔드 관점에서 웹사이트 접근 과정의 성능을 최적화하는 기법들을 소개합니다.

### 네트워크 최적화

1. **TCP 최적화**:
   - TCP 윈도우 크기 조정
   - TCP Fast Open 활용
   - Nagle 알고리즘 비활성화 (필요한 경우)

2. **연결 재사용**:
   - HTTP Keep-Alive 활성화
   - 연결 풀링 구현

3. **프로토콜 최적화**:
   - HTTP/2 또는 HTTP/3 사용
   - TLS 1.3 사용 (연결 설정 시간 단축)

### 서버 최적화

1. **비동기 I/O**:
   - Node.js의 이벤트 루프
   - Nginx의 이벤트 기반 아키텍처
   - 비차단 I/O 활용

2. **로드 밸런싱**:
   - 라운드 로빈, 최소 연결 등의 알고리즘
   - 헬스 체크를 통한 장애 서버 감지

3. **캐싱 전략**:
   - 메모리 캐시 (Redis, Memcached)
   - HTTP 캐시 헤더 최적화
   - CDN 활용

## 9. 보안 고려사항

백엔드 관점에서 웹사이트 접근 과정에서 고려해야 할 보안 요소들을 설명합니다.

### 전송 계층 보안

1. **TLS/SSL**:
   - 데이터 암호화로 도청 방지
   - 서버 인증을 통한 중간자 공격 방지
   - 최신 TLS 버전 사용 (TLS 1.3 권장)

2. **인증서 관리**:
   - 신뢰할 수 있는 CA에서 발급된 인증서 사용
   - 인증서 갱신 자동화
   - OCSP Stapling 구현

### 네트워크 보안

1. **방화벽 설정**:
   - 필요한 포트만 개방
   - IP 기반 접근 제한
   - 비정상 트래픽 탐지 및 차단

2. **DDoS 방어**:
   - 트래픽 제한 (Rate Limiting)
   - SYN 쿠키 활성화
   - CDN 또는 DDoS 보호 서비스 활용

### 애플리케이션 보안

1. **입력 검증**:
   - 모든 사용자 입력 검증
   - SQL 인젝션, XSS 방지
   - CSRF 토큰 사용

2. **인증 및 권한**:
   - 강력한 비밀번호 정책
   - 다중 인증(MFA) 구현
   - 최소 권한 원칙 적용

## 참고 자료

- [RFC 1122: Requirements for Internet Hosts](https://tools.ietf.org/html/rfc1122)
- [RFC 793: Transmission Control Protocol](https://tools.ietf.org/html/rfc793)
- [RFC 9110: HTTP Semantics](https://tools.ietf.org/html/rfc9110)
- [High Performance Browser Networking](https://hpbn.co/)
- [Web.dev: 웹 성능 최적화](https://web.dev/performance-optimizing-content-efficiency/)