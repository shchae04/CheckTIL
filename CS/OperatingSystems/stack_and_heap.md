# 스택과 힙 (Stack and Heap)

스택과 힙은 프로그램 실행 시 사용되는 두 가지 주요 메모리 영역입니다.

## 1. 스택 메모리 (Stack Memory)

### 설명
스택은 함수 호출과 관련된 정보를 저장하는 메모리 영역으로, 후입선출(LIFO: Last-In-First-Out) 구조를 가집니다. 함수가 호출될 때마다 스택에 새로운 프레임이 생성되고, 함수가 종료되면 해당 프레임이 제거됩니다.

### 주요 특징
- **정적 메모리 할당**: 컴파일 시간에 크기가 결정됨
- **자동 메모리 관리**: 함수 호출이 끝나면 자동으로 메모리 해제
- **빠른 접근 속도**: 메모리 할당 및 해제가 단순한 포인터 이동으로 이루어짐
- **제한된 크기**: 운영체제에 의해 프로세스당 할당되는 크기가 제한됨 (일반적으로 몇 MB)
- **연속적인 메모리 블록**: 메모리가 연속적으로 할당됨

### 스택에 저장되는 데이터
- **지역 변수**: 함수 내에서 선언된 변수
- **함수 매개변수**: 함수 호출 시 전달되는 인자
- **반환 주소**: 함수 종료 후 돌아갈 주소
- **레지스터 값**: 함수 호출 전 CPU 레지스터 상태

### 스택 오버플로우 (Stack Overflow)
스택의 크기를 초과하는 데이터가 저장되려고 할 때 발생하는 오류입니다.

#### 예시 (Java)
```java
public class StackOverflowExample {
    public static void recursiveFunction(int n) {
        // 종료 조건이 없는 재귀 호출
        System.out.println("Recursive call: " + n);
        recursiveFunction(n + 1);
    }

    public static void main(String[] args) {
        // 스택 오버플로우 발생
        recursiveFunction(1);
    }
}
```

#### 실행 결과
```
Recursive call: 1
Recursive call: 2
...
Recursive call: 11827
Exception in thread "main" java.lang.StackOverflowError
```

### 스택 프레임 구조
함수 호출마다 생성되는 스택 프레임의 일반적인 구조입니다.

```
높은 주소
+------------------+
| 반환 주소        |
+------------------+
| 이전 프레임 포인터|
+------------------+
| 레지스터 저장 공간|
+------------------+
| 지역 변수        |
+------------------+
| 함수 매개변수    |
+------------------+
낮은 주소
```

## 2. 힙 메모리 (Heap Memory)

### 설명
힙은 동적으로 할당되는 메모리를 관리하는 영역으로, 프로그램 실행 중에 필요에 따라 메모리를 할당하고 해제할 수 있습니다. 데이터 구조의 힙(이진 힙 등)과는 다른 개념입니다.

### 주요 특징
- **동적 메모리 할당**: 런타임에 크기가 결정됨
- **수동 메모리 관리**: 프로그래머가 명시적으로 할당 및 해제 (또는 가비지 컬렉션)
- **상대적으로 느린 접근 속도**: 메모리 할당 및 해제가 복잡한 과정을 거침
- **큰 크기**: 일반적으로 스택보다 훨씬 큰 메모리 공간 사용 가능
- **비연속적인 메모리 블록**: 메모리가 비연속적으로 할당될 수 있음

### 힙에 저장되는 데이터
- **동적으로 할당된 객체**: new, malloc 등으로 생성된 객체
- **배열**: 크기가 런타임에 결정되는 배열
- **복잡한 데이터 구조**: 연결 리스트, 트리, 그래프 등
- **전역 변수**: 프로그램 전체에서 접근 가능한 변수 (일부 언어에서)

### 메모리 누수 (Memory Leak)
할당된 힙 메모리가 더 이상 필요하지 않은데도 해제되지 않는 현상입니다.

#### 예시 (C++)
```cpp
#include <iostream>

void memoryLeakFunction() {
    // 메모리 할당
    int* array = new int[1000];

    // 배열 사용
    array[0] = 100;

    // 메모리 해제를 하지 않고 함수 종료
    // delete[] array; // 이 라인이 없으면 메모리 누수 발생
}

int main() {
    // 반복적으로 함수 호출하면 메모리 누수가 누적됨
    for (int i = 0; i < 1000; i++) {
        memoryLeakFunction();
    }

    std::cout << "함수가 1000번 호출되었습니다." << std::endl;
    return 0;
}
```

### 힙 단편화 (Heap Fragmentation)
메모리 할당과 해제를 반복하면서 발생하는 메모리 공간의 비효율적인 분할 현상입니다.

#### 외부 단편화 (External Fragmentation)
충분한 총 메모리가 있지만 연속된 블록이 없어 할당이 불가능한 상태입니다.

#### 내부 단편화 (Internal Fragmentation)
할당된 메모리 블록이 요청된 크기보다 커서 일부 공간이 낭비되는 상태입니다.

## 3. 스택과 힙 비교

### 메모리 할당 방식 비교

| 특성 | 스택 (Stack) | 힙 (Heap) |
|------|-------------|-----------|
| 할당 방식 | 정적 할당 | 동적 할당 |
| 관리 주체 | 컴파일러 | 프로그래머/가비지 컬렉터 |
| 수명 | 함수 호출 기간 | 명시적 해제 또는 가비지 컬렉션까지 |
| 크기 제한 | 상대적으로 작음 | 상대적으로 큼 |
| 할당/해제 속도 | 매우 빠름 | 상대적으로 느림 |
| 단편화 | 발생하지 않음 | 발생 가능 |
| 접근 패턴 | 순차적 | 임의적 |
| 스레드 안전성 | 스레드별 독립적 | 공유 가능, 동기화 필요 |

### 언어별 메모리 관리 방식

#### C/C++
```cpp
void stackAndHeapExample() {
    // 스택 할당
    int stackArray[100];

    // 힙 할당
    int* heapArray = new int[100];

    // 힙 메모리 사용
    heapArray[0] = 42;

    // 힙 메모리 해제 (필수)
    delete[] heapArray;
}
```

#### Java
```java
public void stackAndHeapExample() {
    // 스택에 할당된 기본 타입 변수
    int stackValue = 42;

    // 힙에 할당된 객체
    Integer heapValue = Integer.valueOf(42);

    // 힙에 할당된 배열
    int[] heapArray = new int[100];

    // Java에서는 명시적 메모리 해제가 필요 없음 (가비지 컬렉션)
}
```

#### Python
```python
def stack_and_heap_example():
    # 스택에 할당된 변수 참조
    stack_value = 42

    # 힙에 할당된 객체
    heap_list = [0] * 100

    # Python에서는 모든 객체가 힙에 할당되고
    # 참조 카운팅과 가비지 컬렉션으로 관리됨
```

## 4. 메모리 레이아웃

### 프로세스 메모리 레이아웃
일반적인 프로세스의 메모리 레이아웃은 다음과 같습니다.

```
높은 주소
+------------------+
| 커널 공간        | (운영체제 전용)
+------------------+
| 명령행 인자 및 환경변수 |
+------------------+
| 스택             | (위에서 아래로 성장)
|        ↓         |
+------------------+
|                  |
| 사용되지 않는 공간 |
|                  |
+------------------+
|        ↑         |
| 힙               | (아래에서 위로 성장)
+------------------+
| BSS 세그먼트     | (초기화되지 않은 전역/정적 변수)
+------------------+
| 데이터 세그먼트   | (초기화된 전역/정적 변수)
+------------------+
| 텍스트 세그먼트   | (프로그램 코드)
+------------------+
낮은 주소
```

### 스택과 힙의 충돌
스택과 힙이 서로를 향해 성장하다가 만나면 충돌이 발생할 수 있습니다.

#### 예시 상황
```
1. 프로그램 시작: 스택과 힙 사이에 충분한 공간이 있음
   +--------+                +--------+
   | 스택   |                | 힙     |
   +--------+                +--------+

2. 많은 함수 호출로 스택이 성장
   +----------------+        +--------+
   | 스택           |        | 힙     |
   +----------------+        +--------+

3. 동시에 많은 동적 할당으로 힙이 성장
   +----------------+    +------------+
   | 스택           |    | 힙         |
   +----------------+    +------------+

4. 충돌 발생
   +----------------++------------+
   | 스택           || 힙         |
   +----------------++------------+

   결과: 메모리 오류 발생 (세그멘테이션 폴트 등)
```

## 5. 최적화 및 모범 사례

### 스택 최적화
- **재귀 함수 제한**: 깊은 재귀는 스택 오버플로우를 유발할 수 있으므로 꼬리 재귀 최적화 또는 반복문으로 대체
- **지역 변수 크기 제한**: 대용량 배열이나 구조체는 힙에 할당
- **인라인 함수 활용**: 함수 호출 오버헤드 감소

### 힙 최적화
- **메모리 풀링**: 자주 사용되는 크기의 객체를 위한 메모리 풀 사용
- **적절한 초기 크기 설정**: 자주 크기가 변경되는 자료구조의 경우 초기 크기를 적절히 설정
- **불필요한 할당/해제 최소화**: 객체 재사용 및 메모리 할당 패턴 최적화

### 언어별 모범 사례

#### C/C++
- RAII(Resource Acquisition Is Initialization) 패턴 사용
- 스마트 포인터 활용 (std::unique_ptr, std::shared_ptr)
- 메모리 누수 탐지 도구 사용 (Valgrind, AddressSanitizer)

#### Java
- 불필요한 객체 생성 피하기: 객체 생성은 비용이 많이 드는 작업
- 명시적으로 null 설정하여 참조 해제: 큰 객체의 경우 GC 힌트 제공
- 약한 참조(WeakReference) 활용: 메모리 부족 시 GC가 우선적으로 수거할 수 있게 함

#### Python
- 순환 참조 피하기: 참조 카운팅 방식의 한계 보완
- 컨텍스트 매니저(with 문) 활용: 리소스 자동 정리
- 제너레이터 활용: 대용량 데이터 처리 시 메모리 효율성 향상

## 6. 결론

스택과 힙은 프로그램 실행에 핵심적인 역할을 하는 메모리 영역으로, 각각 고유한 특성과 용도를 지니고 있다. 스택은 함수 호출과 관련된 데이터를 저장하는 정적 메모리 영역으로, 빠른 접근 속도와 자동 메모리 관리가 강점이다. 반면 힙은 동적 메모리 할당을 위한 영역으로, 유연한 메모리 사용이 가능하지만 상대적으로 관리가 복잡하며 성능 저하나 메모리 누수의 위험이 존재한다.

따라서 안정적이고 효율적인 프로그램을 개발하기 위해서는 스택과 힙의 차이를 명확히 이해하고, 언어와 실행 환경에 맞는 적절한 메모리 관리 전략을 적용하는 것이 중요하다. 특히 메모리 누수, 단편화, 스택 오버플로우와 같은 문제를 예방하기 위해 모범적인 메모리 사용 습관을 갖추는 것이 필수적이다.