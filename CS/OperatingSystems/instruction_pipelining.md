# 명령어 파이프라이닝 (Instruction Pipelining)

## 개요

명령어 파이프라이닝(instruction pipelining)은 CPU가 여러 명령어를 동시에 처리하기 위해 각 명령어를 여러 단계로 분할하고, 각 단계를 다른 명령어와 겹쳐서 실행하는 방법입니다. 전통적인 CPU는 한 번에 하나의 명령어를 처리하는 반면, 파이프라인 기법을 사용하는 CPU는 여러 명령어를 각기 다른 단계에서 동시에 처리할 수 있습니다.

## 파이프라인의 기본 단계

일반적인 명령어 파이프라인은 다음과 같은 단계로 구성됩니다:

1. **명령어 인출(Instruction Fetch, IF)**: 메모리에서 명령어를 가져옵니다.
2. **명령어 해독(Instruction Decode, ID)**: 명령어의 의미를 해석합니다.
3. **실행(Execute, EX)**: 명령어에 따라 연산을 수행합니다.
4. **메모리 접근(Memory Access, MEM)**: 필요한 경우 메모리에 접근합니다.
5. **레지스터 쓰기(Write Back, WB)**: 연산 결과를 레지스터에 저장합니다.

## 파이프라인의 장점

1. **처리량 증가**: 여러 명령어를 동시에 처리하므로 전체 처리량이 증가합니다.
2. **CPU 활용도 향상**: 각 하드웨어 유닛이 매 사이클마다 활용됩니다.
3. **클럭 속도 향상**: 각 단계가 간단해져 클럭 속도를 높일 수 있습니다.

## 파이프라인 위험(Pipeline Hazard)

파이프라이닝은 높은 성능을 가져오지만, 때로는 성능 향상에 실패하기도 합니다. 이를 파이프라인 위험(pipeline hazard)이라고 합니다. 파이프라인 위험에는 크게 세 가지 유형이 있습니다:

### 1. 데이터 위험(Data Hazard)

데이터 위험은 데이터 의존적인 두 명령어를 동시에 실행하는 경우, 파이프라인이 제대로 작동하지 않는 것을 의미합니다.

예를 들어, 명령어 B가 명령어 A의 연산 결과인 R에 의존하는 경우, 명령어 A의 결과 저장 단계가 완료되어야 명령어 B가 R을 사용할 수 있습니다.

```
명령어 A: R = X + Y    // R에 X와 Y의 합을 저장
명령어 B: Z = R * 2    // R의 값을 2배하여 Z에 저장
```

이 경우, 명령어 B는 명령어 A가 완료될 때까지 기다려야 합니다.

#### 데이터 위험 해결 방법

1. **파이프라인 지연(Pipeline Stall)**: 의존성이 해결될 때까지 파이프라인을 지연시킵니다.
2. **데이터 포워딩(Data Forwarding)**: 연산 결과를 다음 명령어에 직접 전달합니다.
3. **컴파일러 최적화**: 컴파일러가 명령어 순서를 재배치하여 의존성을 최소화합니다.

### 2. 제어 위험(Control Hazard)

제어 위험은 분기(branch)나 조건문 등으로 인해 다음에 실행할 명령어가 무엇인지 결정되지 않아 파이프라인이 멈추게 되는 것을 의미합니다.

예를 들어, 조건부 분기 명령어가 실행될 때, 분기 조건이 평가되기 전까지는 다음에 어떤 명령어를 실행할지 알 수 없습니다.

```
if (X > Y) goto LABEL_A
// 다음 명령어는?
```

#### 제어 위험 해결 방법

1. **분기 예측(Branch Prediction)**: 분기의 결과를 예측하여 파이프라인을 계속 진행합니다.
2. **지연된 분기(Delayed Branch)**: 분기 명령어 이후에 몇 개의 명령어를 항상 실행합니다.
3. **분기 대상 버퍼(Branch Target Buffer)**: 이전 분기 결과를 저장하여 예측에 활용합니다.

분기 예측 기법이 사용되기도 하지만, 예측에 실패하면 계산된 파이프라인은 모두 버려야 해서 성능 저하가 발생합니다.

### 3. 구조적 위험(Structural Hazard)

구조적 위험은 한 명령어가 자원을 사용하면, 해당 자원이 필요한 다른 명령어는 멈추게 되어 파이프라인이 제대로 작동하지 않는 것을 의미합니다.

서로 다른 명령어가 동시에 ALU, 레지스터와 같은 CPU 자원을 사용하려 할 때 발생합니다.

예를 들어, 한 명령어가 메모리에서 데이터를 읽는 동시에 다른 명령어가 메모리에서 명령어를 인출하려고 할 때, 메모리 접근 충돌이 발생할 수 있습니다.

#### 구조적 위험 해결 방법

1. **자원 복제(Resource Duplication)**: 충돌이 발생하는 자원을 복제합니다.
2. **파이프라인 지연(Pipeline Stall)**: 자원이 사용 가능해질 때까지 기다립니다.
3. **자원 예약(Resource Reservation)**: 자원 사용 일정을 미리 계획합니다.

## 슈퍼스칼라 파이프라이닝(Superscalar Pipelining)

현대 CPU는 단일 파이프라인을 넘어 여러 개의 파이프라인을 병렬로 운영하는 슈퍼스칼라 아키텍처를 채택하고 있습니다. 이를 통해 한 클럭 사이클에 여러 개의 명령어를 동시에 처리할 수 있어 성능이 더욱 향상됩니다.

## 결론

명령어 파이프라이닝은 CPU 성능을 향상시키는 중요한 기술이지만, 다양한 위험 요소로 인해 이론적인 성능 향상을 항상 달성하기는 어렵습니다. 현대 프로세서는 이러한 위험을 최소화하기 위해 분기 예측, 데이터 포워딩, 아웃 오브 오더 실행(out-of-order execution) 등 다양한 기술을 사용하고 있습니다.