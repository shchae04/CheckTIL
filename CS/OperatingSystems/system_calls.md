# 시스템 콜 (System Call)

시스템 콜은 사용자 프로그램이 운영체제의 서비스를 요청하기 위한 인터페이스입니다.

## 1. 시스템 콜이란?

### 정의
시스템 콜(System Call)은 사용자 모드에서 실행되는 프로그램이 커널 모드의 운영체제 서비스를 제공받기 위한 요청을 의미합니다. 이는 일종의 소프트웨어 인터럽트로 작동합니다.

### 필요성
운영체제는 사용자가 실행하는 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호합니다. 이는 다음과 같은 이유 때문입니다:

- **자원 보호**: 프로그램이 CPU, 메모리, 하드 디스크에 마음대로 접근하면 자원이 무질서하게 관리될 수 있음
- **시스템 안정성**: 한 프로그램의 실수가 전체 컴퓨터에 영향을 주는 것을 방지
- **보안**: 악의적인 프로그램으로부터 시스템을 보호

## 2. 이중 모드 (Dual Mode)

시스템 콜은 이중 모드를 통해 구현됩니다. 이중 모드는 CPU가 명령을 실행하는 모드를 사용자 모드와 커널 모드로 구분하는 방식입니다.

### 사용자 모드 (User Mode)
- **특징**: 운영체제 서비스를 제공받을 수 없는 실행 모드
- **제한사항**: 입출력 명령어와 같은 하드웨어 자원 접근 명령을 실행할 수 없음
- **실행 대상**: 일반 프로그램들이 기본적으로 사용자 모드로 실행됨

### 커널 모드 (Kernel Mode)
- **특징**: 운영체제 서비스를 제공받을 수 있는 실행 모드
- **권한**: 커널 영역의 코드를 실행할 수 있음
- **기능**: 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행 가능
- **실행 대상**: 운영체제가 커널 모드로 실행됨

## 3. 시스템 콜 동작 과정

### 실행 흐름
1. **요청 발생**: 사용자 모드의 프로그램이 시스템 콜을 호출
2. **모드 전환**: CPU가 사용자 모드에서 커널 모드로 전환
3. **작업 백업**: CPU가 현재까지의 작업을 백업
4. **서비스 실행**: 커널 영역 내의 시스템 콜을 수행하는 인터럽트 서비스 루틴 실행
5. **복귀**: 기존 실행하고 있던 프로그램으로 복귀하여 실행 계속

### 소프트웨어 인터럽트
시스템 콜은 소프트웨어 인터럽트의 한 종류입니다:
- **트리거**: 시스템 콜을 발생시키는 명령어 실행
- **처리**: 인터럽트 서비스 루틴을 통해 요청된 서비스 수행
- **복원**: 원래 프로그램의 실행 상태로 복귀

## 4. 시스템 콜의 종류

### 프로세스 제어
- `fork()`: 새로운 프로세스 생성
- `exec()`: 프로그램 실행
- `wait()`: 자식 프로세스 대기
- `exit()`: 프로세스 종료

### 파일 관리
- `open()`: 파일 열기
- `read()`: 파일 읽기
- `write()`: 파일 쓰기
- `close()`: 파일 닫기

### 장치 관리
- `ioctl()`: 장치 제어
- `read()`: 장치에서 읽기
- `write()`: 장치에 쓰기

### 정보 유지
- `getpid()`: 프로세스 ID 획득
- `alarm()`: 알람 설정
- `sleep()`: 프로세스 일시 정지

### 통신
- `pipe()`: 파이프 생성
- `shmget()`: 공유 메모리 생성
- `mmap()`: 메모리 매핑

## 5. 시스템 콜 예시

### C 언어 예시
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;
    
    // fork() 시스템 콜 - 새로운 프로세스 생성
    pid = fork();
    
    if (pid == 0) {
        // 자식 프로세스
        printf("자식 프로세스: PID = %d\n", getpid());
    } else if (pid > 0) {
        // 부모 프로세스
        printf("부모 프로세스: PID = %d, 자식 PID = %d\n", getpid(), pid);
        wait(NULL); // 자식 프로세스 대기
    } else {
        // fork() 실패
        printf("fork() 실패\n");
    }
    
    return 0;
}
```

### Java에서의 시스템 콜
Java는 직접적인 시스템 콜 대신 JVM을 통해 간접적으로 시스템 콜을 사용합니다:

```java
import java.io.*;

public class SystemCallExample {
    public static void main(String[] args) {
        try {
            // 파일 쓰기 - 내부적으로 write() 시스템 콜 사용
            FileWriter writer = new FileWriter("example.txt");
            writer.write("Hello, System Call!");
            writer.close();
            
            // 파일 읽기 - 내부적으로 read() 시스템 콜 사용
            BufferedReader reader = new BufferedReader(new FileReader("example.txt"));
            String line = reader.readLine();
            System.out.println("파일 내용: " + line);
            reader.close();
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 6. 시스템 콜의 장단점

### 장점
- **보안성**: 하드웨어 자원에 대한 안전한 접근 제공
- **안정성**: 시스템 전체의 안정성 보장
- **추상화**: 복잡한 하드웨어 세부사항을 숨김
- **이식성**: 다양한 하드웨어에서 동일한 인터페이스 제공

### 단점
- **성능 오버헤드**: 모드 전환으로 인한 성능 저하
- **복잡성**: 시스템 콜 인터페이스 학습의 복잡성
- **제한된 기능**: 운영체제가 제공하는 기능에만 의존

## 7. 시스템 콜과 라이브러리 함수

### 시스템 콜
- **직접 호출**: 커널에 직접 요청
- **예시**: `read()`, `write()`, `open()`
- **특징**: 모드 전환 발생

### 라이브러리 함수
- **간접 호출**: 내부적으로 시스템 콜 사용
- **예시**: `printf()`, `scanf()`, `fopen()`
- **특징**: 버퍼링 등 추가 기능 제공

```c
// 시스템 콜 직접 사용
int fd = open("file.txt", O_RDONLY);
read(fd, buffer, size);
close(fd);

// 라이브러리 함수 사용
FILE *fp = fopen("file.txt", "r");
fread(buffer, size, 1, fp);
fclose(fp);
```

## 8. 정리

시스템 콜은 사용자 프로그램과 운영체제 간의 중요한 인터페이스입니다. 이중 모드를 통해 시스템의 보안과 안정성을 보장하면서도, 프로그램이 필요한 시스템 자원에 접근할 수 있도록 합니다. 비록 성능 오버헤드가 있지만, 현대 운영체제에서는 필수불가결한 메커니즘입니다.

### 핵심 포인트
- 시스템 콜은 소프트웨어 인터럽트의 일종
- 사용자 모드와 커널 모드 간의 안전한 전환 제공
- 하드웨어 자원에 대한 보호된 접근 방법
- 운영체제 서비스를 이용하기 위한 표준 인터페이스