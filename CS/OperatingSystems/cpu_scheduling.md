# CPU 스케줄링 (CPU Scheduling)

## CPU 스케줄링이란?

CPU 스케줄링은 운영체제가 여러 프로세스들 중에서 어떤 프로세스에게 CPU를 할당할지 결정하는 메커니즘입니다. 다중 프로그래밍 환경에서 CPU 이용률을 최대화하고 시스템 성능을 향상시키기 위한 핵심 기능입니다.

### 주요 목표
- **CPU 이용률 최대화**: CPU가 유휴 상태에 있지 않도록 관리
- **처리량(Throughput) 향상**: 단위 시간당 완료되는 프로세스 수 증가
- **반환 시간(Turnaround Time) 최소화**: 프로세스 제출부터 완료까지의 시간 단축
- **대기 시간(Waiting Time) 최소화**: Ready Queue에서 대기하는 시간 감소
- **응답 시간(Response Time) 최소화**: 요청 후 첫 응답까지의 시간 단축

## 선점형 vs 비선점형 스케줄링

### 선점형 스케줄링 (Preemptive Scheduling)

**특징:**
- 실행 중인 프로세스를 중단시키고 다른 프로세스에게 CPU를 할당할 수 있음
- 우선순위가 높은 프로세스가 도착하면 현재 실행 중인 프로세스를 중단 가능
- 응답 시간이 빠르고 실시간 시스템에 적합
- Context Switching 오버헤드가 발생할 수 있음

**장점:**
- 높은 우선순위 작업의 빠른 처리
- 시스템 응답성 향상
- 프로세스 독점 방지

**단점:**
- 잦은 Context Switching으로 인한 오버헤드
- 구현이 복잡함
- 동기화 문제 발생 가능

### 비선점형 스케줄링 (Non-preemptive Scheduling)

**특징:**
- 프로세스가 CPU를 할당받으면 작업 완료 또는 자발적 반납까지 계속 사용
- 한 번 실행이 시작되면 끝날 때까지 다른 프로세스가 CPU를 빼앗을 수 없음
- 구현이 간단하고 Context Switching 오버헤드가 적음

**장점:**
- Context Switching 오버헤드 최소화
- 구현이 단순함
- 예측 가능한 실행 패턴

**단점:**
- 긴 프로세스가 CPU를 독점할 수 있음
- 평균 대기 시간이 길어질 수 있음
- 실시간 시스템에 부적합

## CPU 스케줄링 알고리즘

### 1. FCFS (First-Come, First-Served)
- **방식**: 먼저 도착한 프로세스부터 순서대로 처리
- **특징**: 비선점형, 구현이 간단
- **문제점**: Convoy Effect (긴 프로세스 뒤의 짧은 프로세스들이 오래 대기)

### 2. SJF (Shortest Job First)
- **방식**: 실행 시간이 가장 짧은 프로세스부터 처리
- **특징**: 평균 대기 시간 최소화
- **변형**: SRTF (Shortest Remaining Time First) - 선점형 버전
- **문제점**: 실행 시간 예측의 어려움, 기아 현상 발생 가능

### 3. Priority Scheduling
- **방식**: 우선순위가 높은 프로세스부터 처리
- **특징**: 선점형/비선점형 모두 가능
- **문제점**: 기아 현상 (낮은 우선순위 프로세스의 무한 대기)

### 4. Round Robin (RR)
- **방식**: 각 프로세스에 동일한 시간 할당량(Time Quantum) 부여
- **특징**: 선점형, 공평한 CPU 할당
- **장점**: 응답 시간 보장, 기아 현상 없음
- **단점**: Time Quantum 설정에 따른 성능 차이

### 5. Multilevel Queue
- **방식**: 프로세스를 여러 큐로 분류하여 관리
- **특징**: 각 큐마다 다른 스케줄링 알고리즘 적용 가능
- **예시**: 시스템 프로세스, 대화형 프로세스, 배치 프로세스 등으로 분류

### 6. Multilevel Feedback Queue
- **방식**: 프로세스가 큐 간 이동 가능한 다단계 큐
- **특징**: 동적으로 우선순위 조정
- **장점**: 적응적이고 유연한 스케줄링

## 기아 현상과 해결 방법

### 기아 현상 (Starvation)
우선순위가 낮은 프로세스가 무한정 대기하는 현상으로, 우선순위 기반 스케줄링에서 주로 발생합니다.

### 해결 방법

#### 1. Aging (에이징)
- **개념**: 오래 대기한 프로세스의 우선순위를 점진적으로 증가
- **구현 방법**:
    - 일정 시간마다 대기 중인 프로세스의 우선순위를 1씩 증가
    - 대기 시간에 비례하여 우선순위 보정값 적용
- **효과**: 장기간 대기한 프로세스도 결국 실행 기회를 얻음

#### 2. Time Slicing with Round Robin
- **개념**: 모든 프로세스에게 공평한 CPU 시간 보장
- **구현**: 우선순위와 관계없이 일정 시간 할당
- **효과**: 기아 현상 원천 차단

#### 3. Priority Ceiling
- **개념**: 우선순위에 상한선 설정
- **구현**: 일정 시간 후 모든 프로세스의 우선순위를 재조정
- **효과**: 극단적인 우선순위 차이 방지

#### 4. Fair Share Scheduling
- **개념**: 사용자나 그룹별로 CPU 시간을 공평하게 분배
- **구현**: 전체 CPU 시간을 할당량으로 나누어 관리
- **효과**: 시스템 레벨에서 공정성 보장

## 실제 적용 사례

### Linux CFS (Completely Fair Scheduler)
- 가상 런타임을 기반으로 한 공평한 스케줄링
- Red-Black Tree를 사용한 효율적인 프로세스 관리
- 낮은 레이턴시와 높은 처리량 동시 달성

### Windows Thread Scheduling
- 우선순위 기반의 선점형 스케줄링
- 32단계 우선순위 레벨
- 동적 우선순위 부스팅으로 응답성 향상

## 정리

CPU 스케줄링은 운영체제의 핵심 기능으로, 시스템의 성능과 응답성을 결정하는 중요한 요소입니다. 
각 알고리즘은 장단점이 있으며, 시스템의 목적과 특성에 맞는 적절한 스케줄링 정책을 선택하는 것이 중요합니다. 특히 기아 현상과 같은 문제를 해결하기 위한 에이징 같은 기법을 통해 공정성과 효율성의 균형을 맞추는 것이 중요합니다.