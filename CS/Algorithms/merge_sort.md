# 병합 정렬 (Merge Sort)

## 개요
병합 정렬은 분할 정복(Divide and Conquer) 알고리즘의 대표적인 예로, 배열을 절반으로 나누고, 각 부분을 재귀적으로 정렬한 다음 두 부분을 병합하는 방식으로 동작합니다. 안정적인 정렬 알고리즘으로, 최악의 경우에도 O(n log n)의 시간 복잡도를 보장합니다.

## 알고리즘 작동 방식
1. 배열을 절반으로 나눕니다(분할).
2. 각 부분 배열을 재귀적으로 정렬합니다(정복).
3. 정렬된 두 부분 배열을 하나의 정렬된 배열로 병합합니다(결합).
4. 부분 배열의 크기가 1 이하가 되면 재귀를 종료합니다.

## 의사코드 (Pseudocode)
```
mergeSort(arr, left, right):
    if left < right:
        mid = (left + right) / 2
        
        // 왼쪽 부분 배열 정렬
        mergeSort(arr, left, mid)
        
        // 오른쪽 부분 배열 정렬
        mergeSort(arr, mid + 1, right)
        
        // 정렬된 두 부분 배열 병합
        merge(arr, left, mid, right)

merge(arr, left, mid, right):
    // 두 부분 배열의 크기 계산
    n1 = mid - left + 1
    n2 = right - mid
    
    // 임시 배열 생성
    L[1...n1], R[1...n2]
    
    // 데이터를 임시 배열로 복사
    for i from 1 to n1:
        L[i] = arr[left + i - 1]
    for j from 1 to n2:
        R[j] = arr[mid + j]
    
    // 두 임시 배열을 병합
    i = 1, j = 1, k = left
    while i <= n1 and j <= n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i = i + 1
        else:
            arr[k] = R[j]
            j = j + 1
        k = k + 1
    
    // 남은 원소들을 복사
    while i <= n1:
        arr[k] = L[i]
        i = i + 1
        k = k + 1
    
    while j <= n2:
        arr[k] = R[j]
        j = j + 1
        k = k + 1
```

## Java 구현
```java
/**
 * 병합 정렬 구현 클래스
 * 배열을 반으로 나누고 정렬하여 다시 병합하는 방식
 */
public class MergeSort {
    /**
     * 병합 정렬을 수행하는 메소드
     * @param arr 정렬할 정수 배열
     * @param l 정렬할 범위의 시작 인덱스
     * @param r 정렬할 범위의 끝 인덱스
     */
    public static void mergeSort(int[] arr, int l, int r) {
        if (l < r) {  // 정렬할 원소가 2개 이상인 경우에만 수행
            int m = (l + r) / 2;  // 중간 지점 계산

            // 배열의 왼쪽 부분 정렬
            mergeSort(arr, l, m);
            // 배열의 오른쪽 부분 정렬
            mergeSort(arr, m + 1, r);
            // 정렬된 두 부분을 병합
            merge(arr, l, m, r);
        }
    }

    /**
     * 두 정렬된 부분 배열을 병합하는 메소드
     * @param arr 병합할 배열
     * @param l 왼쪽 부분의 시작 인덱스
     * @param m 왼쪽 부분의 끝 인덱스
     * @param r 오른쪽 부분의 끝 인덱스
     */
    private static void merge(int[] arr, int l, int m, int r) {
        // 왼쪽과 오른쪽 부분 배열의 크기 계산
        int n1 = m - l + 1;  // 왼쪽 부분의 크기
        int n2 = r - m;      // 오른쪽 부분의 크기

        // 임시 배열 생성
        int[] L = new int[n1];  // 왼쪽 부분을 저장할 임시 배열
        int[] R = new int[n2];  // 오른쪽 부분을 저장할 임시 배열

        // 데이터를 임시 배열로 복사
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];  // 왼쪽 부분 복사
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];  // 오른쪽 부분 복사

        // 두 임시 배열을 병합하여 원래 배열에 저장
        int i = 0;  // 왼쪽 배열의 인덱스
        int j = 0;  // 오른쪽 배열의 인덱스
        int k = l;  // 병합된 배열의 인덱스

        // 두 배열의 원소를 비교하여 작은 값부터 병합
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];  // 왼쪽 배열의 원소가 더 작으면 추가
                i++;
            } else {
                arr[k] = R[j];  // 오른쪽 배열의 원소가 더 작으면 추가
                j++;
            }
            k++;
        }

        // 왼쪽 배열에 남은 원소들을 복사
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // 오른쪽 배열에 남은 원소들을 복사
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}
```

## 예시
배열 `[64, 25, 12, 22, 11]`을 병합 정렬로 정렬하는 과정:

**초기 상태**: `[64, 25, 12, 22, 11]`

**분할 과정**:
1. 배열을 절반으로 나눔: `[64, 25]` 및 `[12, 22, 11]`
2. 왼쪽 부분 배열 `[64, 25]`를 다시 나눔: `[64]` 및 `[25]`
   - `[64]`와 `[25]`는 크기가 1이므로 더 이상 나눌 수 없음
   - 병합: `[25, 64]`
3. 오른쪽 부분 배열 `[12, 22, 11]`을 다시 나눔: `[12]` 및 `[22, 11]`
   - `[12]`는 크기가 1이므로 더 이상 나눌 수 없음
   - `[22, 11]`을 다시 나눔: `[22]` 및 `[11]`
   - `[22]`와 `[11]`은 크기가 1이므로 더 이상 나눌 수 없음
   - 병합: `[11, 22]`
   - 병합: `[11, 12, 22]`

**최종 병합**:
- 왼쪽 부분 배열: `[25, 64]`
- 오른쪽 부분 배열: `[11, 12, 22]`
- 병합 결과: `[11, 12, 22, 25, 64]`

최종 정렬된 배열: `[11, 12, 22, 25, 64]`

## 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균 경우**: O(n log n)
- **최악의 경우**: O(n log n)

병합 정렬은 입력 배열의 상태와 관계없이 항상 일정한 시간 복잡도를 가집니다.

## 공간 복잡도
- **O(n)** - 병합 과정에서 원본 배열과 같은 크기의 추가 메모리 공간이 필요합니다.

## 장점
1. 안정 정렬(stable sort) - 동일한 값을 가진 요소의 상대적 순서가 유지됨
2. 최악의 경우에도 O(n log n)의 시간 복잡도를 보장
3. 대규모 데이터셋에서 효율적
4. 연결 리스트(linked list)에 대해 효율적으로 구현 가능
5. 외부 정렬(external sorting)에 적합

## 단점
1. 추가 메모리 공간이 필요 (제자리 정렬이 아님)
2. 작은 배열에서는 오버헤드로 인해 삽입 정렬보다 느릴 수 있음
3. 캐시 지역성(cache locality)이 퀵 정렬보다 좋지 않을 수 있음
4. 재귀 호출로 인한 스택 오버플로우 가능성

## 활용
- 대규모 데이터셋 정렬
- 안정적인 정렬이 필요한 경우
- 외부 정렬 알고리즘의 기본 구성 요소
- 연결 리스트 정렬
- 병렬 처리가 가능한 환경에서의 정렬

## 병합 정렬의 변형
1. **자연 병합 정렬(Natural Merge Sort)**: 이미 정렬된 부분 시퀀스를 활용하여 성능 향상
2. **상향식 병합 정렬(Bottom-up Merge Sort)**: 재귀 호출 없이 반복적으로 구현
3. **티머 정렬(Timsort)**: 삽입 정렬과 병합 정렬을 결합한 하이브리드 알고리즘 (Python, Java 등에서 사용)
4. **병렬 병합 정렬(Parallel Merge Sort)**: 다중 스레드 환경에서 병렬로 처리

## 다른 정렬 알고리즘과의 비교
| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정성 |
|---------|-----------------|-----------|-------|
| 병합 정렬 | O(n log n) | O(n) | 안정 |
| 퀵 정렬 | O(n log n) | O(log n) | 불안정 |
| 버블 정렬 | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(1) | 안정 |
| 힙 정렬 | O(n log n) | O(1) | 불안정 |