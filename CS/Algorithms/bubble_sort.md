# 버블 정렬 (Bubble Sort)

## 개요
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 인접한 두 원소를 비교하여 필요한 경우 위치를 교환하는 방식으로 동작합니다. 이 과정을 배열이 정렬될 때까지 반복합니다. 이름이 '버블(거품)'인 이유는 정렬 과정에서 큰 값들이 마치 거품처럼 배열의 끝으로 떠오르기 때문입니다.

## 알고리즘 작동 방식
1. 배열의 첫 번째 원소부터 시작하여 인접한 원소와 비교합니다.
2. 현재 원소가 다음 원소보다 크면 두 원소의 위치를 교환합니다.
3. 다음 원소로 이동하여 2번 과정을 반복합니다.
4. 배열의 끝까지 도달하면 가장 큰 원소가 배열의 마지막 위치에 놓이게 됩니다.
5. 1~4 과정을 배열의 크기 - 1번 반복하여 전체 배열을 정렬합니다.
6. 각 반복마다 이미 정렬된 원소(배열의 뒷부분)는 비교에서 제외합니다.

## 의사코드 (Pseudocode)
```
bubbleSort(arr):
    n = length(arr)
    
    for i from 0 to n-2:
        for j from 0 to n-i-2:
            if arr[j] > arr[j+1]:
                swap arr[j] and arr[j+1]
```

## Java 구현
```java
/**
 * 버블 정렬 구현 클래스
 * 인접한 두 원소를 비교하여 정렬하는 방식
 */
public class BubbleSort {
    /**
     * 버블 정렬을 수행하는 메소드
     * @param arr 정렬할 정수 배열
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;  // 배열의 길이

        // 전체 원소에 대해 반복
        for (int i = 0; i < n-1; i++) {
            // 각 회전에서 인접한 원소들을 비교
            // i번째 회전 후에는 끝에서 i개의 원소는 이미 정렬되어 있으므로 n-i-1까지만 비교
            for (int j = 0; j < n-i-1; j++) {
                // 현재 원소가 다음 원소보다 크면 교환
                if (arr[j] > arr[j+1]) {
                    // 두 원소의 위치를 교환
                    int temp = arr[j];        // 임시 변수에 현재 원소 저장
                    arr[j] = arr[j+1];        // 다음 원소를 현재 위치로 이동
                    arr[j+1] = temp;          // 임시 저장한 원소를 다음 위치로 이동
                }
            }
        }
    }
}
```

## 최적화된 버블 정렬
기본 버블 정렬은 이미 정렬된 배열에 대해서도 모든 비교를 수행합니다. 다음과 같이 최적화할 수 있습니다:

```java
public static void optimizedBubbleSort(int[] arr) {
    int n = arr.length;
    boolean swapped;
    
    for (int i = 0; i < n-1; i++) {
        swapped = false;
        
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swapped = true;
            }
        }
        
        // 교환이 발생하지 않았다면 배열이 이미 정렬된 상태
        if (!swapped) {
            break;
        }
    }
}
```

## 예시
배열 `[64, 25, 12, 22, 11]`을 버블 정렬로 정렬하는 과정:

**첫 번째 패스:**
- `[64, 25, 12, 22, 11]` → `[25, 64, 12, 22, 11]` (64와 25 비교 및 교환)
- `[25, 64, 12, 22, 11]` → `[25, 12, 64, 22, 11]` (64와 12 비교 및 교환)
- `[25, 12, 64, 22, 11]` → `[25, 12, 22, 64, 11]` (64와 22 비교 및 교환)
- `[25, 12, 22, 64, 11]` → `[25, 12, 22, 11, 64]` (64와 11 비교 및 교환)

**두 번째 패스:**
- `[25, 12, 22, 11, 64]` → `[12, 25, 22, 11, 64]` (25와 12 비교 및 교환)
- `[12, 25, 22, 11, 64]` → `[12, 22, 25, 11, 64]` (25와 22 비교 및 교환)
- `[12, 22, 25, 11, 64]` → `[12, 22, 11, 25, 64]` (25와 11 비교 및 교환)

**세 번째 패스:**
- `[12, 22, 11, 25, 64]` → `[12, 22, 11, 25, 64]` (12와 22 비교, 교환 없음)
- `[12, 22, 11, 25, 64]` → `[12, 11, 22, 25, 64]` (22와 11 비교 및 교환)

**네 번째 패스:**
- `[12, 11, 22, 25, 64]` → `[11, 12, 22, 25, 64]` (12와 11 비교 및 교환)

최종 정렬된 배열: `[11, 12, 22, 25, 64]`

## 시간 복잡도
- **최선의 경우**: O(n) - 최적화된 버블 정렬에서 이미 정렬된 배열
- **평균 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 배열

## 공간 복잡도
- **O(1)** - 추가 메모리 공간을 거의 사용하지 않는 제자리 정렬(in-place sorting) 알고리즘입니다.

## 장점
1. 구현이 매우 간단하고 이해하기 쉬움
2. 추가 메모리 공간이 거의 필요 없음
3. 안정 정렬(stable sort) - 동일한 값을 가진 요소의 상대적 순서가 유지됨
4. 작은 데이터셋에서는 효율적일 수 있음

## 단점
1. 시간 복잡도가 O(n²)로 대규모 데이터셋에서는 매우 비효율적
2. 다른 O(n²) 정렬 알고리즘(선택 정렬, 삽입 정렬)보다도 일반적으로 성능이 떨어짐
3. 교환 연산의 횟수가 많음

## 활용
- 교육 목적으로 기본 정렬 알고리즘을 설명할 때
- 매우 작은 데이터셋을 정렬할 때
- 이미 거의 정렬된 데이터를 정렬할 때 (최적화된 버블 정렬 사용 시)
- 메모리 사용이 제한적인 환경에서

## 다른 정렬 알고리즘과의 비교
| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정성 |
|---------|-----------------|-----------|-------|
| 버블 정렬 | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(1) | 안정 |
| 퀵 정렬 | O(n log n) | O(log n) | 불안정 |
| 병합 정렬 | O(n log n) | O(n) | 안정 |
| 힙 정렬 | O(n log n) | O(1) | 불안정 |