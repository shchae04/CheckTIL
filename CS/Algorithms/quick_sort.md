# 퀵 정렬 (Quick Sort)

## 개요
퀵 정렬은 분할 정복(Divide and Conquer) 방법을 기반으로 하는 효율적인 정렬 알고리즘입니다. 피벗(pivot)이라 불리는 원소를 기준으로 배열을 두 부분으로 분할하고, 각 부분을 재귀적으로 정렬합니다. 평균적으로 매우 빠른 성능을 보이며, 실제 많은 프로그래밍 언어의 표준 라이브러리에서 사용되는 정렬 알고리즘입니다.

## 알고리즘 작동 방식
1. 배열에서 피벗(pivot)을 선택합니다(일반적으로 마지막 원소).
2. 피벗보다 작은 모든 원소는 피벗의 왼쪽으로, 큰 원소는 오른쪽으로 이동시킵니다(분할 과정).
3. 피벗이 자신의 최종 위치에 놓이게 됩니다.
4. 피벗을 기준으로 나뉜 두 부분 배열에 대해 재귀적으로 1~3 과정을 반복합니다.
5. 부분 배열의 크기가 1 이하가 되면 재귀를 종료합니다.

## 의사코드 (Pseudocode)
```
quickSort(arr, low, high):
    if low < high:
        // 피벗을 기준으로 배열을 분할하고 피벗의 최종 위치를 받음
        pivotIndex = partition(arr, low, high)
        
        // 피벗을 기준으로 왼쪽 부분 배열 정렬
        quickSort(arr, low, pivotIndex - 1)
        
        // 피벗을 기준으로 오른쪽 부분 배열 정렬
        quickSort(arr, pivotIndex + 1, high)

partition(arr, low, high):
    pivot = arr[high]  // 마지막 원소를 피벗으로 선택
    i = low - 1        // 피벗보다 작은 원소들의 경계를 나타내는 인덱스
    
    for j from low to high-1:
        if arr[j] < pivot:
            i = i + 1
            swap arr[i] and arr[j]
    
    swap arr[i+1] and arr[high]  // 피벗을 올바른 위치로 이동
    return i + 1                  // 피벗의 최종 위치 반환
```

## Java 구현
```java
/**
 * 퀵 정렬 구현 클래스
 * 피벗을 기준으로 작은 값과 큰 값을 분할하여 정렬하는 방식
 */
public class QuickSort {
    /**
     * 퀵 정렬을 수행하는 메소드
     * @param arr 정렬할 정수 배열
     * @param low 정렬할 범위의 시작 인덱스
     * @param high 정렬할 범위의 끝 인덱스
     */
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {  // 정렬할 원소가 2개 이상인 경우에만 수행
            // 피벗을 기준으로 배열을 분할하고 피벗의 최종 위치를 받음
            int pi = partition(arr, low, high);

            // 피벗을 기준으로 왼쪽 부분 배열 정렬
            quickSort(arr, low, pi - 1);
            // 피벗을 기준으로 오른쪽 부분 배열 정렬
            quickSort(arr, pi + 1, high);
        }
    }

    /**
     * 배열을 피벗을 기준으로 분할하는 메소드
     * @param arr 분할할 배열
     * @param low 분할할 범위의 시작 인덱스
     * @param high 분할할 범위의 끝 인덱스
     * @return 피벗의 최종 위치
     */
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];  // 마지막 원소를 피벗으로 선택
        int i = (low - 1);      // 피벗보다 작은 원소들의 경계를 나타내는 인덱스

        // low부터 high-1까지 순회하며 피벗과 비교
        for (int j = low; j < high; j++) {
            // 현재 원소가 피벗보다 작으면
            if (arr[j] < pivot) {
                i++;  // 경계를 오른쪽으로 이동
                // 현재 원소를 경계 왼쪽으로 이동
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // 피벗을 올바른 위치로 이동
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;  // 피벗의 최종 위치 반환
    }
}
```

## 예시
배열 `[64, 25, 12, 22, 11]`을 퀵 정렬로 정렬하는 과정:

**초기 상태**: `[64, 25, 12, 22, 11]`  
피벗: 11 (마지막 원소)

**첫 번째 분할**:
- 11보다 작은 원소가 없으므로 i = -1로 유지
- 64 > 11, 25 > 11, 12 > 11, 22 > 11이므로 모든 원소가 피벗보다 큼
- 피벗을 i+1 위치로 이동: `[11, 64, 25, 12, 22]`
- 피벗의 최종 위치: 0

**왼쪽 부분 배열**: 없음 (피벗이 첫 번째 위치에 있으므로)

**오른쪽 부분 배열**: `[64, 25, 12, 22]`  
피벗: 22 (마지막 원소)

**두 번째 분할 (오른쪽 부분 배열)**:
- 64 > 22, i = 0
- 25 > 22, i = 0
- 12 < 22, i = 1, 교환 후: `[11, 12, 64, 25, 22]`
- 피벗을 i+1 위치로 이동: `[11, 12, 22, 64, 25]`
- 피벗의 최종 위치: 2

**왼쪽 부분 배열**: `[12]` (크기가 1이므로 정렬 완료)

**오른쪽 부분 배열**: `[64, 25]`  
피벗: 25 (마지막 원소)

**세 번째 분할 (오른쪽 부분 배열)**:
- 64 > 25, i = 2
- 피벗을 i+1 위치로 이동: `[11, 12, 22, 25, 64]`
- 피벗의 최종 위치: 3

**왼쪽 부분 배열**: 없음
**오른쪽 부분 배열**: `[64]` (크기가 1이므로 정렬 완료)

최종 정렬된 배열: `[11, 12, 22, 25, 64]`

## 시간 복잡도
- **최선의 경우**: O(n log n) - 피벗이 항상 배열을 균등하게 분할할 때
- **평균 경우**: O(n log n)
- **최악의 경우**: O(n²) - 피벗이 항상 최소값이나 최대값일 때(이미 정렬된 배열에서 첫 번째나 마지막 원소를 피벗으로 선택할 경우)

## 공간 복잡도
- **O(log n)** - 재귀 호출로 인한 스택 공간 (최악의 경우 O(n))

## 장점
1. 평균적으로 매우 빠른 정렬 알고리즘 (O(n log n))
2. 추가 메모리 공간을 적게 사용하는 제자리 정렬(in-place sorting)
3. 캐시 지역성(cache locality)이 좋아 실제 성능이 우수함
4. 대규모 데이터셋에서도 효율적
5. 다양한 피벗 선택 전략으로 최적화 가능

## 단점
1. 최악의 경우 시간 복잡도가 O(n²)로 성능이 저하될 수 있음
2. 불안정 정렬(unstable sort) - 동일한 값을 가진 요소의 상대적 순서가 변경될 수 있음
3. 이미 정렬된 배열에서는 성능이 저하될 수 있음 (피벗 선택 방법에 따라 다름)
4. 재귀 호출로 인한 스택 오버플로우 가능성

## 활용
- 대규모 데이터셋 정렬
- 평균적으로 빠른 성능이 필요한 경우
- 많은 프로그래밍 언어의 표준 라이브러리 정렬 함수 (예: Java의 Arrays.sort(), C++의 std::sort())
- 데이터베이스 시스템의 정렬 연산

## 퀵 정렬의 변형
1. **랜덤 피벗 선택**: 최악의 경우를 피하기 위해 피벗을 무작위로 선택
2. **중간값 피벗 선택**: 첫 번째, 중간, 마지막 원소 중 중간값을 피벗으로 선택
3. **듀얼 피벗 퀵 정렬(Dual-Pivot QuickSort)**: 두 개의 피벗을 사용하여 배열을 세 부분으로 분할
4. **인트로 정렬(Introsort)**: 퀵 정렬과 힙 정렬을 결합하여 최악의 경우를 방지

## 다른 정렬 알고리즘과의 비교
| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정성 |
|---------|-----------------|-----------|-------|
| 퀵 정렬 | O(n log n) | O(log n) | 불안정 |
| 버블 정렬 | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(1) | 안정 |
| 병합 정렬 | O(n log n) | O(n) | 안정 |
| 힙 정렬 | O(n log n) | O(1) | 불안정 |