# 멀티웨이 탐색트리(Multi-way Search Tree)

## 1. 한 줄 정의
멀티웨이 탐색트리는 한 노드가 여러 개의 키와 자식 포인터를 가져 이진탐색트리보다 더 넓고 얕은 구조를 이루는 트리로, 노드의 차수(order)에 따라 데이터 조회 및 삽입 성능이 결정된다.

---

## 2. 멀티웨이 탐색트리의 특성 비교

### 2-1. 노드 구조(Node Structure)
- **이진탐색트리**: 각 노드가 최대 1개의 키와 2개의 자식 포인터
- **멀티웨이 탐색트리(M-way)**: 각 노드가 최대 (M-1)개의 키와 M개의 자식 포인터

```
이진탐색트리 노드:
┌─────────────────┐
│   key           │
│ /     \         │
```

멀티웨이 탐색트리(3-way) 노드:
┌─────────────────────────────────┐
│  key1  │  key2                  │
│ /  │  \  │  \                   │
```

### 2-2. 키 정렬 규칙(Ordering)
- **이진탐색트리**: left < node < right
- **멀티웨이 탐색트리**: key1 < key2 < ... < keyN이고, 각 자식 서브트리의 값들도 정렬 순서 유지

```
3-way 탐색트리 예시:
        [30 | 70]
        /    │    \
      /      │      \
    [15]   [40|60]  [80|90]
```

### 2-3. 트리의 높이(Height)
- **이진탐색트리**: 높이 = O(log N) ~ O(N) (불균형 가능)
- **멀티웨이 탐색트리**: 높이 = O(logM N) (더 낮은 높이)

```python
# 높이 비교
이진탐색트리: 1000개 노드 → 높이 약 10 (균형)
3-way 트리: 1000개 노드 → 높이 약 6
4-way 트리: 1000개 노드 → 높이 약 5
```

### 2-4. 검색 시간 복잡도(Search Complexity)
- **이진탐색트리**: O(log N)
- **멀티웨이 탐색트리**: O(logM N) (M이 크면 더 적음)

```python
# 탐색 비교
이진탐색트리: 32개 노드 → 최대 5번 비교
3-way 트리: 32개 노드 → 최대 3번 비교
5-way 트리: 32개 노드 → 최대 2번 비교
```

### 2-5. 노드 내 탐색(In-node Search)
- **이진탐색트리**: 노드 내 비교 불필요 (1개 키)
- **멀티웨이 탐색트리**: 노드 내에서 여러 키 중 선택 (이진탐색 필요)

```python
# 노드 내 탐색
def search_in_node(node, key):
    # 이진탐색 또는 선형탐색으로 (M-1)개 키 중 위치 결정
    for i in range(node.num_keys):
        if key < node.keys[i]:
            return i  # i번째 자식으로 이동
    return node.num_keys
```

---

## 3. 차수(Order)에 따른 구현 특성

### 3-1. 2-way 트리 (이진탐색트리)
```
특성: 각 노드 최대 1개 키, 2개 자식
장점: 구현 단순
단점: 높이가 높을 수 있음

    [50]
    /   \
  [30]  [70]
  / \   / \
```

### 3-2. 3-way 트리
```
특성: 각 노드 최대 2개 키, 3개 자식
장점: 높이 감소, 캐시 효율성
단점: 노드 관리 복잡

     [40|70]
    /  │  \
  [20] [55] [80]
```

### 3-3. M-way 트리 (일반형)
```
특성: 각 노드 최대 (M-1)개 키, M개 자식
장점: 높이 최소화, 디스크 I/O 최소화
단점: 구현 복잡도 증가, 노드 내 탐색 오버헤드

예: B-tree, B+-tree로 확장
```

---

## 4. 사용 사례

### 4-1. 멀티웨이 탐색트리를 사용하는 경우
- **데이터베이스 인덱싱**: B-tree (M = 차수)
- **파일 시스템**: 디렉토리 구조 (디스크 I/O 최소화)
- **메모리 캐시**: 낮은 높이로 빠른 접근
- **외부 메모리 탐색**: 디스크 블록 크기와 맞춘 차수 선택

```python
# 데이터베이스 인덱싱 예시
# B-tree (3-order): 각 블록이 2개 키 저장
# 1000만 레코드: 높이 약 3-4 (디스크 I/O 3-4회)
```

### 4-2. 이진탐색트리를 선호하는 경우
- **메모리 기반 탐색**: 단순한 구조 선호
- **교육/학습**: 개념 이해 용이
- **실시간 처리**: 균형이 잘 유지된 경우

```python
# AVL tree, Red-Black tree 사용
# 자동 균형 유지, 구현은 복잡하지만 이진 구조 유지
```

---

## 5. 백엔드 개발자 관점의 중요성

### 5-1. 데이터베이스 설계
- **B-tree 인덱싱**: 대규모 데이터셋에서 멀티웨이 구조로 높이 최소화
- **범위 검색**: B+-tree의 리프 노드 링크로 효율적 범위 조회

### 5-2. 성능 최적화
- **디스크 I/O**: 노드 크기를 디스크 블록 크기(4KB)에 맞춰 최적화
- **캐시 지역성**: 노드의 모든 키를 한 번에 메모리에 로드
- **높이 감소**: 트리 높이 감소 → 접근 횟수 감소

### 5-3. 스케일링 고려사항
- **메모리**: 노드 크기 증가 → 트리 높이 감소 (트레이드오프)
- **삽입/삭제**: 노드 분할(split), 병합(merge) 복잡도
- **동시성**: 멀티웨이 트리의 락 전략 필요

```
B-tree 높이와 I/O 비교:
이진탐색트리(높이 20): 약 20번의 디스크 접근
3-order B-tree(높이 4): 약 4번의 디스크 접근
```

---

## 6. 핵심 요약

| 특성 | 이진탐색트리 | 멀티웨이 탐색트리 |
|------|-----------|---------------|
| **노드당 키 개수** | 1개 | M-1개 |
| **노드당 자식** | 최대 2개 | 최대 M개 |
| **높이** | O(log N) ~ O(N) | O(logM N) |
| **노드 내 탐색** | 불필요 | 필요 (이진탐색) |
| **구현 복잡도** | 단순 | 중간~복잡 |
| **메모리 효율** | 좋음 | 노드당 키 많음 |
| **디스크 I/O** | 많음 | 적음 |
| **캐시 효율** | 보통 | 좋음 |

### 6-1. 선택 기준
- **메모리 내 탐색** → 이진탐색트리 (AVL, Red-Black)
- **디스크 기반 저장** → 멀티웨이 트리 (B-tree)
- **높이 최소화 필요** → 높은 차수의 멀티웨이 트리
- **균형 유지 중요** → 균형 이진탐색트리

### 6-2. 실무 팁
- **데이터베이스 인덱싱**: B-tree/B+-tree 사용 (표준)
- **파일 시스템**: 트리 차수 = (블록 크기) / (키 크기)로 설정
- **메모리 제약**: 노드 크기와 자식 포인터 수 최적화
- **범위 검색**: B+-tree의 리프 노드 링크 활용

---

## 7. 트리 구현 비교

### 7-1. 이진탐색트리 삽입
```python
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert_bst(node, key):
    if node is None:
        return BSTNode(key)
    if key < node.key:
        node.left = insert_bst(node.left, key)
    else:
        node.right = insert_bst(node.right, key)
    return node
```

### 7-2. 멀티웨이 탐색트리 삽입 (개념)
```python
class MWTNode:
    def __init__(self, order):
        self.keys = []        # 최대 order-1개
        self.children = []    # 최대 order개
        self.is_leaf = True

def insert_mwt(node, key, order):
    # 1. 적절한 자식 찾기
    child_index = find_child_index(node, key)

    # 2. 리프 노드에 도달할 때까지 재귀
    if node.is_leaf:
        node.keys.insert(child_index, key)
        if len(node.keys) >= order:
            split_node(node, order)  # 노드 분할
    else:
        insert_mwt(node.children[child_index], key, order)
```

---

## 8. 고급 개념: B-tree

멀티웨이 탐색트리의 실제 구현:
- **특징**: 모든 리프 노드가 같은 높이, 자동 균형 유지
- **차수**: 데이터베이스 블록 크기에 따라 결정
- **성능**: O(logM N) 보장, 디스크 I/O 최적화

```
B-tree 성질:
1. 각 노드는 최대 M개 자식 (M-1개 키)
2. 루트 제외 각 노드는 최소 ⌈M/2⌉개 자식
3. 모든 리프 노드는 같은 높이
4. 키는 정렬 순서 유지
```
