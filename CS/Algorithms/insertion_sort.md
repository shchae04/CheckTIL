# 삽입 정렬 (Insertion Sort)

## 개요
삽입 정렬은 손안의 카드를 정렬하는 방법과 유사한 정렬 알고리즘입니다. 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 부분과 비교하여 자신의 위치를 찾아 삽입합니다. 정렬되지 않은 부분에서 원소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작합니다.

## 알고리즘 작동 방식
1. 배열의 두 번째 원소부터 시작합니다(첫 번째 원소는 그 자체로 정렬되어 있다고 간주).
2. 현재 원소를 key로 저장합니다.
3. key 이전의 원소들을 역순으로 비교하면서, key보다 큰 원소들을 한 칸씩 뒤로 이동시킵니다.
4. key를 적절한 위치에 삽입합니다.
5. 배열의 모든 원소에 대해 2~4 과정을 반복합니다.

## 의사코드 (Pseudocode)
```
insertionSort(arr):
    n = length(arr)
    
    for i from 1 to n-1:
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j = j - 1
            
        arr[j+1] = key
```

## Java 구현
```java
/**
 * 삽입 정렬 구현 클래스
 * 정렬되지 않은 부분에서 원소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식
 */
public class InsertionSort {
    /**
     * 삽입 정렬을 수행하는 메소드
     * @param arr 정렬할 정수 배열
     */
    public static void insertionSort(int[] arr) {
        int n = arr.length;  // 배열의 길이

        // 두 번째 원소부터 시작하여 끝까지 반복
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // 현재 삽입할 원소를 key로 저장
            int j = i - 1;     // key 이전의 원소부터 비교 시작

            // key보다 큰 원소들을 뒤로 한 칸씩 이동
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];  // 한 칸 뒤로 이동
                j = j - 1;            // 이전 원소로 이동
            }

            arr[j + 1] = key;  // key를 적절한 위치에 삽입
        }
    }
}
```

## 예시
배열 `[64, 25, 12, 22, 11]`을 삽입 정렬로 정렬하는 과정:

**초기 상태**: `[64, 25, 12, 22, 11]`  
(첫 번째 원소 64는 이미 정렬되어 있다고 간주)

**첫 번째 패스 (i=1, key=25)**:
- 25와 64를 비교: 25 < 64이므로 64를 한 칸 뒤로 이동
- 25를 올바른 위치에 삽입: `[25, 64, 12, 22, 11]`

**두 번째 패스 (i=2, key=12)**:
- 12와 64를 비교: 12 < 64이므로 64를 한 칸 뒤로 이동
- 12와 25를 비교: 12 < 25이므로 25를 한 칸 뒤로 이동
- 12를 올바른 위치에 삽입: `[12, 25, 64, 22, 11]`

**세 번째 패스 (i=3, key=22)**:
- 22와 64를 비교: 22 < 64이므로 64를 한 칸 뒤로 이동
- 22와 25를 비교: 22 < 25이므로 25를 한 칸 뒤로 이동
- 22와 12를 비교: 22 > 12이므로 이동 없음
- 22를 올바른 위치에 삽입: `[12, 22, 25, 64, 11]`

**네 번째 패스 (i=4, key=11)**:
- 11과 64를 비교: 11 < 64이므로 64를 한 칸 뒤로 이동
- 11과 25를 비교: 11 < 25이므로 25를 한 칸 뒤로 이동
- 11과 22를 비교: 11 < 22이므로 22를 한 칸 뒤로 이동
- 11과 12를 비교: 11 < 12이므로 12를 한 칸 뒤로 이동
- 11을 올바른 위치에 삽입: `[11, 12, 22, 25, 64]`

최종 정렬된 배열: `[11, 12, 22, 25, 64]`

## 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 배열
- **평균 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 배열

## 공간 복잡도
- **O(1)** - 추가 메모리 공간을 거의 사용하지 않는 제자리 정렬(in-place sorting) 알고리즘입니다.

## 장점
1. 구현이 간단하고 이해하기 쉬움
2. 작은 데이터셋에서 효율적
3. 안정 정렬(stable sort) - 동일한 값을 가진 요소의 상대적 순서가 유지됨
4. 대부분 정렬된 배열에서 매우 효율적 (거의 O(n) 시간 복잡도)
5. 온라인 알고리즘(online algorithm) - 데이터가 들어오는 대로 정렬 가능
6. 제자리 정렬(in-place sorting) - 추가 메모리 공간이 거의 필요 없음

## 단점
1. 시간 복잡도가 O(n²)로 대규모 데이터셋에서는 비효율적
2. 배열이 역순으로 정렬되어 있을 때 최악의 성능을 보임
3. 선택 정렬이나 버블 정렬과 마찬가지로 대규모 데이터셋에서는 퀵 정렬, 병합 정렬, 힙 정렬보다 느림

## 활용
- 작은 크기의 배열을 정렬할 때
- 대부분 정렬된 배열을 정렬할 때
- 온라인으로 데이터가 들어오는 경우
- 메모리 사용이 제한적인 환경에서
- 간단한 구현이 필요한 경우

## 다른 정렬 알고리즘과의 비교
| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정성 |
|---------|-----------------|-----------|-------|
| 삽입 정렬 | O(n²) | O(1) | 안정 |
| 버블 정렬 | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(1) | 불안정 |
| 퀵 정렬 | O(n log n) | O(log n) | 불안정 |
| 병합 정렬 | O(n log n) | O(n) | 안정 |
| 힙 정렬 | O(n log n) | O(1) | 불안정 |

## 삽입 정렬의 변형
1. **이진 삽입 정렬(Binary Insertion Sort)**: 이진 검색을 사용하여 삽입 위치를 찾음으로써 비교 횟수를 줄임
2. **셸 정렬(Shell Sort)**: 삽입 정렬의 개선된 버전으로, 멀리 떨어진 요소들을 먼저 비교하여 큰 값을 빠르게 이동시킴