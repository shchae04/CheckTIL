# 힙 정렬 (Heap Sort)

## 개요
힙 정렬은 완전 이진 트리(Complete Binary Tree)의 일종인 힙(Heap) 자료구조를 활용한 정렬 알고리즘입니다. 최대 힙(Max Heap) 또는 최소 힙(Min Heap)을 구성하여 정렬을 수행합니다. 힙 정렬은 불안정 정렬이지만, 최악의 경우에도 O(n log n)의 시간 복잡도를 보장하며 추가 메모리를 거의 사용하지 않는 장점이 있습니다.

## 알고리즘 작동 방식
1. 주어진 배열을 최대 힙(Max Heap)으로 구성합니다.
   - 최대 힙: 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
2. 힙의 루트(최댓값)를 배열의 마지막 원소와 교환합니다.
3. 힙의 크기를 1 감소시키고, 루트 노드에 대해 힙 속성을 다시 만족하도록 조정합니다(heapify).
4. 힙의 크기가 1이 될 때까지 2~3 과정을 반복합니다.

## 의사코드 (Pseudocode)
```
heapSort(arr):
    n = length(arr)
    
    // 초기 최대 힙 구성
    for i from n/2-1 down to 0:
        heapify(arr, n, i)
    
    // 힙에서 원소를 하나씩 꺼내어 정렬
    for i from n-1 down to 1:
        swap arr[0] and arr[i]
        heapify(arr, i, 0)

heapify(arr, n, i):
    largest = i
    left = 2*i + 1
    right = 2*i + 2
    
    // 왼쪽 자식이 현재 노드보다 크면 largest 업데이트
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    // 오른쪽 자식이 현재 노드보다 크면 largest 업데이트
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    // largest가 변경되었다면 교환 후 재귀적으로 heapify 수행
    if largest != i:
        swap arr[i] and arr[largest]
        heapify(arr, n, largest)
```

## Java 구현
```java
/**
 * 힙 정렬 구현 클래스
 * 최대 힙을 구성하여 정렬하는 방식
 */
public class HeapSort {
    /**
     * 힙 정렬을 수행하는 메소드
     * @param arr 정렬할 정수 배열
     */
    public static void heapSort(int[] arr) {
        int n = arr.length;  // 배열의 길이

        // 초기 최대 힙 구성
        // 마지막 비단말 노드부터 시작하여 루트까지 힙 속성을 만족하도록 조정
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // 힙에서 원소를 하나씩 꺼내어 배열의 뒤쪽부터 저장
        for (int i = n-1; i > 0; i--) {
            // 루트(최댓값)를 배열의 마지막 원소와 교환
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // 루트 노드에 대해 힙 속성을 다시 만족하도록 조정
            heapify(arr, i, 0);
        }
    }

    /**
     * 특정 노드를 루트로 하는 서브트리를 최대 힙으로 만드는 메소드
     * @param arr 힙을 구성할 배열
     * @param n 힙의 크기
     * @param i 현재 노드의 인덱스
     */
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;      // 현재 노드를 최댓값으로 가정
        int l = 2*i + 1;     // 왼쪽 자식 노드의 인덱스
        int r = 2*i + 2;     // 오른쪽 자식 노드의 인덱스

        // 왼쪽 자식이 현재 최댓값보다 크면 largest 업데이트
        if (l < n && arr[l] > arr[largest])
            largest = l;

        // 오른쪽 자식이 현재 최댓값보다 크면 largest 업데이트
        if (r < n && arr[r] > arr[largest])
            largest = r;

        // largest가 변경되었다면 (= 자식 노드 중 더 큰 값이 있다면)
        if (largest != i) {
            // 현재 노드와 최댓값 노드를 교환
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // 교환된 자식 노드에 대해 재귀적으로 heapify 수행
            heapify(arr, n, largest);
        }
    }
}
```

## 예시
배열 `[64, 25, 12, 22, 11]`을 힙 정렬로 정렬하는 과정:

**초기 상태**: `[64, 25, 12, 22, 11]`

**최대 힙 구성**:
1. 마지막 비단말 노드(인덱스 1, 값 25)부터 시작하여 heapify 수행:
   - 25의 자식은 22와 11, 둘 다 25보다 작으므로 변경 없음
2. 루트 노드(인덱스 0, 값 64)에 대해 heapify 수행:
   - 64의 자식은 25와 12, 둘 다 64보다 작으므로 변경 없음
   - 최대 힙 구성 완료: `[64, 25, 12, 22, 11]`

**정렬 과정**:
1. 루트(64)와 마지막 원소(11) 교환: `[11, 25, 12, 22, 64]`
   - 힙 크기를 4로 줄이고 루트에 대해 heapify 수행
   - 11의 자식 중 25가 더 크므로 교환: `[25, 11, 12, 22, 64]`
   - 11의 자식 중 22가 더 크므로 교환: `[25, 22, 12, 11, 64]`

2. 루트(25)와 마지막 원소(11) 교환: `[11, 22, 12, 25, 64]`
   - 힙 크기를 3으로 줄이고 루트에 대해 heapify 수행
   - 11의 자식 중 22가 더 크므로 교환: `[22, 11, 12, 25, 64]`

3. 루트(22)와 마지막 원소(12) 교환: `[12, 11, 22, 25, 64]`
   - 힙 크기를 2로 줄이고 루트에 대해 heapify 수행
   - 12의 자식 중 11이 유일하고 12보다 작으므로 변경 없음

4. 루트(12)와 마지막 원소(11) 교환: `[11, 12, 22, 25, 64]`
   - 힙 크기가 1이 되어 정렬 완료

최종 정렬된 배열: `[11, 12, 22, 25, 64]`

## 시간 복잡도
- **최선의 경우**: O(n log n)
- **평균 경우**: O(n log n)
- **최악의 경우**: O(n log n)

힙 정렬은 입력 배열의 상태와 관계없이 항상 일정한 시간 복잡도를 가집니다.

## 공간 복잡도
- **O(1)** - 추가 메모리 공간을 거의 사용하지 않는 제자리 정렬(in-place sorting) 알고리즘입니다.

## 장점
1. 최악의 경우에도 O(n log n)의 시간 복잡도를 보장
2. 추가 메모리 공간을 거의 사용하지 않음
3. 우선순위 큐(Priority Queue) 구현에 활용 가능
4. 정렬해야 할 데이터의 크기가 클 때 효율적

## 단점
1. 불안정 정렬(unstable sort) - 동일한 값을 가진 요소의 상대적 순서가 변경될 수 있음
2. 캐시 지역성(cache locality)이 좋지 않아 실제로는 퀵 정렬보다 느릴 수 있음
3. 이미 정렬된 데이터에 대해 성능 향상이 없음
4. 구현이 다소 복잡함

## 활용
- 우선순위 큐(Priority Queue) 구현
- 힙 자료구조가 필요한 알고리즘
- 최악의 경우에도 일정한 성능이 필요한 경우
- 제한된 메모리 환경에서의 정렬

## 힙 정렬의 변형
1. **최소 힙 정렬(Min Heap Sort)**: 최소 힙을 사용하여 내림차순으로 정렬
2. **스무스 정렬(Smoothsort)**: 힙 정렬의 변형으로, 이미 정렬된 데이터에 대해 더 효율적
3. **인트로 정렬(Introsort)**: 퀵 정렬과 힙 정렬을 결합한 하이브리드 알고리즘

## 다른 정렬 알고리즘과의 비교
| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정성 |
|---------|-----------------|-----------|-------|
| 힙 정렬 | O(n log n) | O(1) | 불안정 |
| 퀵 정렬 | O(n log n) | O(log n) | 불안정 |
| 병합 정렬 | O(n log n) | O(n) | 안정 |
| 버블 정렬 | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(1) | 안정 |