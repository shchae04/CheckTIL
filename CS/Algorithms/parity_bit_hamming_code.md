# 패리티 비트 & 해밍 코드 (Parity Bit & Hamming Code)

## 개요
패리티 비트와 해밍 코드는 디지털 통신과 저장 시스템에서 데이터의 오류를 검출하고 수정하기 위한 오류 정정 부호(Error Correcting Code, ECC) 기법입니다. 패리티 비트는 가장 간단한 오류 검출 방법이며, 해밍 코드는 Richard Hamming이 개발한 오류 검출 및 수정 알고리즘으로 단일 비트 오류를 자동으로 수정할 수 있습니다.

## 패리티 비트 (Parity Bit)

### 패리티 비트란?
패리티 비트는 데이터의 무결성을 검증하기 위해 추가되는 비트입니다. 데이터 비트들의 1의 개수가 짝수 또는 홀수가 되도록 하는 추가 비트를 말합니다.

### 패리티 비트의 종류
1. **짝수 패리티 (Even Parity)**
   - 전체 비트(데이터 + 패리티)에서 1의 개수가 짝수가 되도록 설정
   - 데이터 비트에서 1의 개수가 홀수이면 패리티 비트 = 1
   - 데이터 비트에서 1의 개수가 짝수이면 패리티 비트 = 0

2. **홀수 패리티 (Odd Parity)**
   - 전체 비트(데이터 + 패리티)에서 1의 개수가 홀수가 되도록 설정
   - 데이터 비트에서 1의 개수가 짝수이면 패리티 비트 = 1
   - 데이터 비트에서 1의 개수가 홀수이면 패리티 비트 = 0

### 패리티 비트 예시
```
예시 1: 짝수 패리티
데이터: 1011001 (1의 개수: 4개 - 짝수)
패리티 비트: 0 (전체 1의 개수를 짝수로 유지)
전송 데이터: 10110010

예시 2: 홀수 패리티
데이터: 1011001 (1의 개수: 4개 - 짝수)
패리티 비트: 1 (전체 1의 개수를 홀수로 만들기)
전송 데이터: 10110011
```

### 패리티 비트의 한계
- **단일 비트 오류만 검출 가능**: 2개 이상의 비트가 동시에 바뀌면 검출 불가
- **오류 수정 불가**: 오류가 발생한 위치를 알 수 없어 수정 불가능
- **짝수 개의 비트 오류는 검출 불가**: 2, 4, 6... 개의 비트가 바뀌면 패리티가 유지됨

## 해밍 코드 (Hamming Code)

### 해밍 코드란?
해밍 코드는 1950년 Richard Hamming이 개발한 선형 오류 정정 부호로, 단일 비트 오류를 검출하고 자동으로 수정할 수 있는 알고리즘입니다. 패리티 비트를 여러 개 사용하여 오류의 정확한 위치를 찾아낼 수 있습니다.

### 해밍 코드의 기본 원리
해밍 코드는 다음과 같은 위치에 패리티 비트를 배치합니다:
- 2^i 번째 위치 (1, 2, 4, 8, 16, ...)에 패리티 비트 배치
- 각 패리티 비트는 특정 패턴의 비트들을 검사

### 해밍(7,4) 코드 구조
가장 일반적인 해밍(7,4) 코드는 4비트 데이터를 7비트로 인코딩합니다:

```
위치:    1  2  3  4  5  6  7
비트:   P1 P2 D1 P3 D2 D3 D4
```

- P1, P2, P3: 패리티 비트 (위치 1, 2, 4)
- D1, D2, D3, D4: 데이터 비트 (위치 3, 5, 6, 7)

### 패리티 비트 계산 규칙
각 패리티 비트는 특정 위치의 비트들을 XOR 연산하여 계산됩니다:

```
P1 (위치 1): 위치 1, 3, 5, 7의 비트들을 XOR
P2 (위치 2): 위치 2, 3, 6, 7의 비트들을 XOR
P3 (위치 4): 위치 4, 5, 6, 7의 비트들을 XOR
```

이는 각 위치를 이진수로 표현했을 때의 비트 패턴과 관련이 있습니다:

```
위치 1 (001): 1번째 비트가 1
위치 2 (010): 2번째 비트가 1
위치 3 (011): 1,2번째 비트가 1
위치 4 (100): 3번째 비트가 1
위치 5 (101): 1,3번째 비트가 1
위치 6 (110): 2,3번째 비트가 1
위치 7 (111): 1,2,3번째 비트가 1
```

## 해밍 코드 인코딩 예시

### 데이터: 1101을 해밍(7,4) 코드로 인코딩

**1단계: 데이터 배치**
```
위치:    1  2  3  4  5  6  7
비트:   P1 P2  1 P3  1  0  1
데이터:     D1    D2 D3 D4
```

**2단계: 패리티 비트 계산**
```
P1 = 위치 1,3,5,7 = P1 ⊕ 1 ⊕ 1 ⊕ 1 = P1 ⊕ 1
P1 = 1 (짝수 패리티 사용)

P2 = 위치 2,3,6,7 = P2 ⊕ 1 ⊕ 0 ⊕ 1 = P2 ⊕ 0
P2 = 0

P3 = 위치 4,5,6,7 = P3 ⊕ 1 ⊕ 0 ⊕ 1 = P3 ⊕ 0
P3 = 0
```

**최종 인코딩 결과**: `1011101`

## 해밍 코드 디코딩 및 오류 수정

### 오류 검출 과정
수신된 데이터에서 각 패리티 비트를 다시 계산하여 오류를 검출합니다.

### 예시: 수신 데이터 `1111101` (3번째 비트에 오류 발생)

**1단계: 패리티 검사**
```
S1 = 위치 1,3,5,7의 패리티 = 1 ⊕ 1 ⊕ 1 ⊕ 1 = 0
S2 = 위치 2,3,6,7의 패리티 = 0 ⊕ 1 ⊕ 0 ⊕ 1 = 0  
S3 = 위치 4,5,6,7의 패리티 = 1 ⊕ 1 ⊕ 0 ⊕ 1 = 1
```

**2단계: 오류 위치 계산**
```
오류 위치 = S3S2S1 = 100 (이진수) = 4 (십진수)
```

하지만 실제로는 3번째 위치에 오류가 있습니다. 다시 정확히 계산해보면:

```
올바른 계산:
S1 = 1 ⊕ 1 ⊕ 1 ⊕ 1 = 0 (패리티 일치)
S2 = 0 ⊕ 1 ⊕ 0 ⊕ 1 = 0 (패리티 불일치 - 원래는 1이어야 함)
S3 = 1 ⊕ 1 ⊕ 0 ⊕ 1 = 1 (패리티 일치)

오류 위치 = 011 (이진수) = 3 (십진수)
```

**3단계: 오류 수정**
3번째 비트를 뒤집어서 `1011101`로 수정

## Java 구현 예시

```java
/**
 * 해밍(7,4) 코드 구현 클래스
 */
public class HammingCode {
    
    /**
     * 4비트 데이터를 해밍(7,4) 코드로 인코딩
     * @param data 4비트 데이터 (0-15)
     * @return 7비트 해밍 코드
     */
    public static int encode(int data) {
        // 데이터 비트 추출
        int d1 = (data >> 3) & 1; // 최상위 비트
        int d2 = (data >> 2) & 1;
        int d3 = (data >> 1) & 1;
        int d4 = data & 1;        // 최하위 비트
        
        // 패리티 비트 계산 (짝수 패리티)
        int p1 = d1 ^ d2 ^ d4;    // 위치 1,3,5,7
        int p2 = d1 ^ d3 ^ d4;    // 위치 2,3,6,7
        int p3 = d2 ^ d3 ^ d4;    // 위치 4,5,6,7
        
        // 해밍 코드 조립 (7비트)
        return (d4 << 6) | (d3 << 5) | (d2 << 4) | (p3 << 3) | 
               (d1 << 2) | (p2 << 1) | p1;
    }
    
    /**
     * 해밍(7,4) 코드를 디코딩하고 오류 수정
     * @param hamming 7비트 해밍 코드
     * @return 수정된 4비트 데이터
     */
    public static DecodingResult decode(int hamming) {
        // 비트 추출
        int p1 = hamming & 1;
        int p2 = (hamming >> 1) & 1;
        int d1 = (hamming >> 2) & 1;
        int p3 = (hamming >> 3) & 1;
        int d2 = (hamming >> 4) & 1;
        int d3 = (hamming >> 5) & 1;
        int d4 = (hamming >> 6) & 1;
        
        // 신드롬 계산
        int s1 = p1 ^ d1 ^ d2 ^ d4;
        int s2 = p2 ^ d1 ^ d3 ^ d4;
        int s3 = p3 ^ d2 ^ d3 ^ d4;
        
        int errorPosition = (s3 << 2) | (s2 << 1) | s1;
        
        boolean hasError = (errorPosition != 0);
        
        // 오류 수정
        if (hasError) {
            hamming ^= (1 << (errorPosition - 1));
            // 수정된 비트 다시 추출
            p1 = hamming & 1;
            p2 = (hamming >> 1) & 1;
            d1 = (hamming >> 2) & 1;
            p3 = (hamming >> 3) & 1;
            d2 = (hamming >> 4) & 1;
            d3 = (hamming >> 5) & 1;
            d4 = (hamming >> 6) & 1;
        }
        
        // 원본 데이터 복원
        int originalData = (d1 << 3) | (d2 << 2) | (d3 << 1) | d4;
        
        return new DecodingResult(originalData, hasError, errorPosition);
    }
    
    /**
     * 디코딩 결과를 담는 클래스
     */
    public static class DecodingResult {
        public final int data;
        public final boolean hasError;
        public final int errorPosition;
        
        public DecodingResult(int data, boolean hasError, int errorPosition) {
            this.data = data;
            this.hasError = hasError;
            this.errorPosition = errorPosition;
        }
    }
    
    /**
     * 테스트 예제
     */
    public static void main(String[] args) {
        // 원본 데이터: 1101 (13)
        int originalData = 13;
        System.out.println("원본 데이터: " + Integer.toBinaryString(originalData) + " (" + originalData + ")");
        
        // 인코딩
        int encoded = encode(originalData);
        System.out.println("인코딩 결과: " + Integer.toBinaryString(encoded) + " (" + encoded + ")");
        
        // 오류 주입 (3번째 비트 뒤집기)
        int corrupted = encoded ^ (1 << 2);
        System.out.println("오류 주입: " + Integer.toBinaryString(corrupted) + " (" + corrupted + ")");
        
        // 디코딩 및 오류 수정
        DecodingResult result = decode(corrupted);
        System.out.println("수정된 데이터: " + Integer.toBinaryString(result.data) + " (" + result.data + ")");
        System.out.println("오류 검출: " + result.hasError);
        System.out.println("오류 위치: " + result.errorPosition);
    }
}
```

## 시간 복잡도 및 공간 복잡도

### 패리티 비트
- **시간 복잡도**: O(n) - n은 데이터 비트 수
- **공간 복잡도**: O(1) - 추가로 1비트만 필요

### 해밍 코드
- **시간 복잡도**: O(log n) - n은 데이터 비트 수
- **공간 복잡도**: O(log n) - log n개의 패리티 비트 필요

## 장점과 단점

### 패리티 비트
**장점:**
- 구현이 매우 간단
- 오버헤드가 적음 (1비트만 추가)
- 단일 비트 오류 검출 가능

**단점:**
- 오류 수정 불가능
- 짝수 개의 비트 오류는 검출 불가
- 오류 위치를 알 수 없음

### 해밍 코드
**장점:**
- 단일 비트 오류 자동 수정 가능
- 2비트 오류까지 검출 가능 (수정은 1비트만)
- 오류 위치 정확히 파악 가능

**단점:**
- 오버헤드가 상대적으로 큼
- 3비트 이상 오류에는 효과적이지 않음
- 구현이 패리티 비트보다 복잡

## 실제 활용 분야

### 패리티 비트
- **메모리 시스템**: ECC 메모리의 기본 구성요소
- **직렬 통신**: UART, RS-232 등의 데이터 전송
- **저장 장치**: 하드디스크, SSD의 오류 검출

### 해밍 코드
- **메모리 시스템**: ECC RAM에서 사용
- **위성 통신**: 우주에서의 방사선에 의한 비트 플립 수정
- **디지털 저장**: CD, DVD 등의 오류 정정
- **네트워크 통신**: 데이터 전송 중 오류 수정

## 확장된 해밍 코드 (SECDED)

해밍 코드에 추가 패리티 비트를 하나 더 추가하면 **SECDED(Single Error Correction, Double Error Detection)** 코드가 됩니다:

- **Single Error Correction**: 1비트 오류 수정
- **Double Error Detection**: 2비트 오류 검출 (수정은 불가)

```
해밍(8,4) SECDED 코드:
위치:    1  2  3  4  5  6  7  8
비트:   P1 P2 D1 P3 D2 D3 D4 P0

P0: 전체 비트의 패리티 (추가 패리티)
```

## 다른 오류 정정 코드와의 비교

| 코드 유형 | 오류 검출 능력 | 오류 수정 능력 | 오버헤드 | 복잡도 |
|---------|-------------|-------------|--------|-------|
| 패리티 비트 | 1비트 | 없음 | 낮음 | 매우 낮음 |
| 해밍 코드 | 2비트 | 1비트 | 중간 | 낮음 |
| BCH 코드 | 다중 비트 | 다중 비트 | 높음 | 높음 |
| Reed-Solomon | 다중 비트 | 다중 비트 | 높음 | 매우 높음 |

## 결론

패리티 비트와 해밍 코드는 디지털 시스템에서 데이터 무결성을 보장하는 핵심 기술입니다. 패리티 비트는 간단한 오류 검출에, 해밍 코드는 자동 오류 수정이 필요한 상황에서 광범위하게 사용됩니다. 현대의 컴퓨터 메모리, 저장 장치, 통신 시스템에서 이러한 오류 정정 기법들이 데이터의 신뢰성을 보장하는 핵심 역할을 하고 있습니다.

이러한 기본적인 오류 정정 개념을 이해하는 것은 시스템의 신뢰성과 안정성을 높이는 데 필수적이며, 더 고급의 오류 정정 코드를 학습하는 데 있어서도 중요한 기초가 됩니다.