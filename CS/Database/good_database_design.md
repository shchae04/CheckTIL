# 좋은 데이터베이스 설계란?

## 1. 한 줄 요약
- 좋은 DB 설계는 “요구사항 기반의 올바른 데이터 모델 + 무결성 제약으로 품질을 강제 + 쿼리/확장/운영을 고려한 실용적 최적화(인덱스·분할·스키마 진화)”의 균형이다.

---

## 2. 목표와 원칙
- 정확성: 도메인 규칙을 스키마(제약)로 강제해 데이터 품질을 코드에만 의존하지 않게 한다.
- 일관성/무결성: 참조 무결성(FK), 도메인 무결성(CHECK), 고유성(UNIQUE), NOT NULL.
- 성능/확장성: 우선순위 높은 접근 패턴에 최적화(인덱스/파티셔닝/샤딩/캐싱).
- 단순성: 필요한 복잡도만 도입. 유지보수성과 가독성 우선.
- 진화 가능성: 스키마 변경을 안전하게, 점진적으로 적용할 수 있게 설계.

---

## 3. 데이터 모델링 단계
1. 개념 모델(Conceptual): 핵심 엔티티와 관계를 비즈니스 언어로 식별.
2. 논리 모델(Logical): 속성, 키, 관계(cardinality/optional), 정규화 고려.
3. 물리 모델(Physical): DBMS 선택, 자료형, 인덱스, 파티션/샤드, 스토리지 옵션.

Tip: 가장 빈번한 쿼리(읽기/쓰기 패턴), 데이터 양과 성장률, 지연 요구사항을 초기부터 명시.

---

## 4. 정규화 vs. 탈정규화
- 정규화 목적: 중복 최소화, 갱신 이상 방지. 1NF–3NF(또는 BCNF)까지가 실무 표준.
- 언제 탈정규화? 성능(조인 감소, 커버링), 복잡한 리포트, 집계 테이블 필요 시.
- 원칙:
  - 기본은 정규화, 탈정규화는 문제/쿼리 근거가 명확할 때만.
  - 중복 필드에는 출처와 동기화 전략을 명확히 문서화(트리거/잡/애플리케이션).

---

## 5. 키, 관계, 제약
- 기본 키(PK): 단순·작은·변하지 않는 값 선호. 고카디널리티 필요.
- 자연키 vs 대리키: 자연키가 변할 수 있으면 대리키(PK) + 자연키 UNIQUE 권장.
- 외래 키(FK): 참조 무결성 강제. ON DELETE/UPDATE 동작을 의도에 맞게 설정.
- 제약: NOT NULL, UNIQUE, CHECK로 도메인 룰을 DB에 명시.
- 타임스탬프/감사 필드: created_at, updated_at, 상태 컬럼으로 변경 추적.

---

## 6. 인덱스와 쿼리 설계
- 인덱스 선택:
  - 선택도(카디널리티) 높고 필터/조인/정렬에 자주 쓰이는 컬럼.
  - 복합 인덱스는 사용 쿼리의 WHERE/ORDER BY 순서를 반영(Leftmost Rule).
  - 커버링 인덱스(SELECT 컬럼 포함)로 랜덤 I/O 감소.
  - 쓰기 비용 고려: 과도한 인덱스는 INSERT/UPDATE/DELETE 비용 증가.
  - 부분/필터 인덱스(PostgreSQL/SQL Server)와 함수/표현식 인덱스 활용.
- 쿼리 패턴 우선: 쿼리를 위한 스키마 설계. 불필요한 N+1, 카테시안 조인 방지.
- 실행계획 점검: EXPLAIN/EXPLAIN ANALYZE로 스캔/조인 전략 확인.

관련 읽기: [행지향 vs 열지향](./row_vs_column_oriented_db.md)

---

## 7. 트랜잭션, 격리, 일관성
- ACID 준수, 비즈니스 단위로 트랜잭션 경계 정의.
- 격리 수준 선택(Read Committed, Repeatable Read, Serializable): 성능 vs 일관성 트레이드오프를 요구사항에 맞춤.
- 이상 현상: Dirty/Non-repeatable/Phantom Read 이해 및 예방.
- 멱등성/재시도: 분산/네트워크 실패 대비하여 키 설계와 상태 전이를 단순화.

관련 읽기: [동시성 제어](./database_concurrency_control.md)

---

## 8. 파티셔닝, 샤딩, 복제
- 파티셔닝: 범위/해시/리스트 기반. 핫 파티션 방지를 위한 키 설계.
- 샤딩: 샤드 키의 균등 분포와 라우팅 단순화가 핵심. 크로스 샤드 조인/트랜잭션 최소화.
- 복제: 리더-팔로워, 다중 리더. 읽기 분산/고가용성. 지연과 일관성 모델 고려.
- 백업/복구/DR: RPO/RTO 목표 수립, 정기 DR 리허설.

관련 읽기: [데이터베이스 복제](./database_replication.md)

---

## 9. 스키마 진화와 운영
- 호환성 원칙: Backward/Forward 호환. 다단계 배포(추가 → 이중쓰기 → 마이그레이션 → 제거).
- 온라인 DDL: 잠금 최소화 옵션/툴 사용. 대용량 테이블은 배치/청크 마이그레이션.
- 기본값/NOT NULL: 단계적으로 적용(컬럼 추가→데이터 채우기→제약 추가).
- 마이그레이션 관리: 버전 관리(Migration 스크립트), 롤백 계획, 데이터 검증.

---

## 10. 워크로드 특성 반영(OLTP vs OLAP)
- OLTP: 짧은 트랜잭션, 높은 동시성, 낮은 지연. 정규화, 행 지향, 좁은 인덱스.
- OLAP: 대량 스캔/집계, 배치 지향. 열 지향, 파티션/클러스터링, 요약 테이블.

관련 읽기: [행 vs 열 지향 DB](./row_vs_column_oriented_db.md)

---

## 11. NoSQL/RDBMS 선택과 혼합 전략
- 액세스 패턴 중심 설계(NoSQL): 쿼리를 먼저 정의하고 스키마/파티션 키 설계.
- 일관성/트랜잭션 요구가 높다면 RDBMS 선호. 문서형/키값 스토어는 유연성/확장성 강점.

관련 읽기: [NoSQL 개요](./nosql_databases.md), [DynamoDB 설계](./dynamodb.md)

---

## 12. 흔한 안티패턴
- EAV(Entity-Attribute-Value) 남용: 조인/검증/인덱싱 악화.
- 제약 미사용: 무결성을 애플리케이션 로직에만 의존.
- 무분별한 UUID v4 PK: 페이지 분산/인덱스 파편화. 필요 시 순서형(UUID v7 등) 또는 별도 서퍼게이트 키 고려.
- 과도한 인덱스: 쓰기 병목과 저장공간 증가.
- 거대 다용도 테이블(“God Table”): 경계 불분명, 잠금 경쟁.
- JSON 컬럼 남용: 필터링/조인 컬럼은 정규 컬럼과 인덱스 활용.

---

## 13. 설계 체크리스트
- 핵심 액세스 패턴(READ/WRITE/REPORT) 정의 완료 여부
- 필수 제약(FK/UNIQUE/NOT NULL/CHECK) 적용 여부
- 주요 쿼리의 인덱스/실행계획 검증(EXPLAIN)
- 파티셔닝/샤딩/복제 전략과 운영 절차 정의
- 스키마 진화 절차(마이그레이션, 롤백, 검증) 수립
- 데이터 보안(민감정보 암호화/마스킹), 감사/추적 가능성
- 백업/복구, 아카이빙, 보존정책

---

## 14. 핵심 정리
- 정규화로 무결성과 유지보수성을 확보하고, 실제 쿼리 패턴을 기준으로 인덱스/탈정규화/분할을 ‘근거 있게’ 적용한다.
- 제약과 트랜잭션으로 데이터 품질을 DB 레벨에서 보장하고, 스키마 진화를 안전하게 운영한다.
- 워크로드 특성(OLTP/OLAP)과 분산 요구(복제/샤딩)를 초기에 반영하면 확장 비용을 크게 줄일 수 있다.

---

## 부록: 실전 예시
- 실전 워크스루: [실전 예시: 데이터 모델링 워크스루 (전자상거래 주문 도메인)](./database_modeling_example.md)
