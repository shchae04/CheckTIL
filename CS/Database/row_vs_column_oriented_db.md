# 행 지향 vs 열 지향 데이터베이스

## 1. 한 줄 요약
- 행 지향은 OLTP(트랜잭션) 위주, 열 지향은 OLAP(분석/스캔) 위주에 강하다. 액세스 패턴에 맞춰 스토리지/압축/인덱싱 전략이 달라진다.

---

## 2. 기본 개념
- 행 지향(Row-Oriented): 한 행의 모든 컬럼을 함께 저장. 전형적인 RDBMS(MySQL, PostgreSQL) 기본 저장 방식.
- 열 지향(Column-Oriented): 하나의 컬럼 단위로 데이터를 묶어 저장. 분석용 DB(ClickHouse, Apache Parquet/ORC, BigQuery)에서 흔함.

---

## 3. 저장 구조와 I/O 특성
- 행 지향:
  - 장점: 단건/소수 행의 전체 컬럼 읽기/쓰기 빠름(INSERT/UPDATE/SELECT * 패턴에 유리)
  - 단점: 일부 컬럼만 필요한 대량 스캔 시 불필요한 I/O 증가
- 열 지향:
  - 장점: 특정 컬럼만 선택해 대량 스캔/집계 시 I/O 최소화, 강력한 압축과 인코딩 가능
  - 단점: 단건 전체 행 읽기/쓰기 비용 높을 수 있음(쓰기-증분/머지 패턴 필요)

---

## 4. 압축/인코딩/인덱싱
- 열 지향:
  - Run-Length Encoding(RLE), Dictionary Encoding, Bit-Packing 등 컬럼 특화 압축으로 저장/스캔 효율↑
  - Zone Map/Min-Max 인덱스, Bloom Filter 등으로 범위 프루닝
- 행 지향:
  - B-Tree/Hash 인덱스 중심, 트랜잭션/잠금/버퍼풀 최적화
  - 커버링 인덱스, 부분 인덱스 등으로 실시간 쿼리 가속

---

## 5. 워크로드 매칭(언제 무엇을 선택할까)
- 행 지향(OLTP):
  - 특성: 짧은 트랜잭션, 높은 동시성, 다수의 작은 쓰기, 강한 일관성
  - 예: 전자상거래 주문, 계정/권한, 실시간 API 백엔드
- 열 지향(OLAP):
  - 특성: 대량 스캔, 집계/리포팅, 배치/스트리밍 적재, 스키마 온 리드 가능
  - 예: 데이터 웨어하우스, BI 대시보드, 로그/이벤트 분석

---

## 6. 하이브리드/혼합 아키텍처
- Lambda/Kappa 스타일: 실시간 저장(행 지향) + DW/레이크로 동기(열 지향)
- HTAP 엔진: 하나의 시스템에서 OLTP+OLAP(예: TiDB+TiFlash, SingleStore)
- CDC/스트리밍으로 OLTP→OLAP 동기화, 모델/스키마는 소비 패턴에 최적화

---

## 7. 설계 팁
- 쿼리 우선: 읽기 패턴(필터/그룹/정렬 컬럼) 기반으로 스토리지 선택
- 파티셔닝/클러스터링 키: 시간/범위 기반으로 프루닝 최적화
- 머티리얼라이즈드 뷰/요약 테이블: 열 지향에서도 비용 높은 집계를 캐싱
- 열 선택성 낮은 경우: 프리디케이트 푸시다운/인덱스/존맵 확인

---

## 8. 주의할 점(안티패턴)
- 열 지향을 OLTP 주 데이터베이스로 사용(단건 쓰기 빈번/강한 트랜잭션 요구) → 지연/비용 상승
- 행 지향에서 대용량 리포트에 JOIN+GROUP BY 남발 → 불필요한 I/O 폭증, 배치로 분리 고려
- 열 지향 파일 포맷(Parquet/ORC) 임의 업데이트 기대 → Append-Only/Compaction 특성 이해 필요

---

## 9. 대표 기술 예시
- 행 지향: PostgreSQL, MySQL(InnoDB), SQL Server, Oracle
- 열 지향: ClickHouse, BigQuery, Redshift, Snowflake, Apache Druid, Apache Pinot, DuckDB
- 파일 포맷: Parquet, ORC (데이터 레이크/레이크하우스)

---

## 10. 핵심 정리
- 트랜잭션 중심이면 행 지향, 분석 중심이면 열 지향을 우선 고려.
- 필요하면 OLTP와 OLAP을 분리하고, CDC/배치로 동기화해 각자의 장점을 취하라.
