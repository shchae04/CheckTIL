# 행 기반 DB vs 열 기반 DB

백엔드/데이터 엔지니어링 면접에서 자주 나오는 주제인 행 기반(Row-oriented)과 열 기반(Column-oriented) 데이터베이스의 차이를 정리합니다.

## 1. 개념 요약
- 행 기반 데이터베이스(Row-oriented Database)
  - 레코드(행) 단위로 데이터를 연속 배치하여 저장/읽기에 최적화된 구조
  - 단건/소수 컬럼 업데이트, 트랜잭션이 많은 OLTP 워크로드에 유리
  - 대표 DB: PostgreSQL, MySQL, MariaDB, Oracle, SQL Server
- 열 기반 데이터베이스(Column-oriented Database)
  - 동일 컬럼의 값들을 연속 배치하여 컬럼 단위로 저장/읽기에 최적화된 구조
  - 필요한 컬럼만 읽어 디스크 I/O를 크게 줄이고, 같은 타입/범위의 값이 연속되어 압축 효율이 높음
  - 대량 스캔, 집계, 분석 쿼리에 유리(OLAP)
  - 대표 DB/서비스: BigQuery, Amazon Redshift, Snowflake, ClickHouse, Vertica

참고: Cassandra/HBase는 "와이드 컬럼 스토어"로 불리지만 내부 저장은 전통적 컬럼 지향과는 다릅니다(분류 목적이 다름). 여기서는 전통적 컬럼 지향(분석형) DB를 중심으로 설명합니다.

## 2. 저장 방식 예시
다음과 같은 테이블이 있다고 가정합니다.

| Name        | CreatedAt   |
|-------------|-------------|
| Atom        | 2024-01-23  |
| Prin        | 2024-02-01  |
| Gosmdochee  | 2024-02-03  |

- 행 기반 저장(행 단위로 인접 배치)
  - [Atom, 2024-01-23] [Prin, 2024-02-01] [Gosmdochee, 2024-02-03]
- 열 기반 저장(컬럼별로 인접 배치)
  - [Atom, Prin, Gosmdochee] [2024-01-23, 2024-02-01, 2024-02-03]

## 3. 성능 특성의 차이
- 읽기 I/O 특성
  - 행 기반: SELECT 시 기본적으로 행 단위 페이지를 읽어 모든(또는 많은) 컬럼을 함께 로드하는 경향 → SELECT * 또는 좁은 범위의 행 조회에 유리
  - 열 기반: 필요한 컬럼만 읽어 I/O를 최소화 → 대량 스캔 + 일부 컬럼만 대상으로 하는 필터/집계에 탁월
- 압축
  - 열 기반은 같은 컬럼 값이 연속 저장되어 런-렝스 인코딩(RLE), 딕셔너리/델타 인코딩 등 고효율 압축 가능 → 저장공간 절감 + 메모리/캐시 효율 상승
- 집계/벡터화 실행
  - 열 기반은 벡터화 실행, SIMD 최적화, late materialization, zone map/min-max 프루닝 등을 활용해 SUM/AVG/COUNT 같은 집계를 매우 빠르게 처리
- 쓰기/업데이트
  - 행 기반: 단일/소량 행 삽입·갱신·삭제에 효율적(B-Tree 인덱스와 잘 맞음)
  - 열 기반: 컬럼 파일에 랜덤 업데이트가 비효율적 → 흔히 LSM/인서트 버퍼/델타 스토어 + 배치 머지(컴팩션) 전략 사용. 실시간 OLTP에는 상대적으로 부적합
- 인덱스/프루닝
  - 행 기반: B-Tree, 해시 인덱스 등 전통 인덱스 중심
  - 열 기반: zone map, 세그먼트 통계, 파티셔닝/클러스터링으로 스캔 범위를 크게 줄임
- 조인/모델링
  - 행 기반: 정규화/다양한 조인에 적합(트랜잭션 특성)
  - 열 기반: 스타 스키마/데이터 마트 등 분석 친화적 모델이 보편, 조인도 가능하나 대개 대량 스캔+집계 중심

## 4. 사용 사례
- 행 기반(OLTP)
  - 사용자 프로필 조회/갱신, 주문 생성, 결제 처리, 다수의 작은 트랜잭션, 낮은 지연시간이 중요한 서비스형 트래픽
- 열 기반(OLAP)
  - 대용량 로그/이벤트 분석, 리포팅, 대시보드, 집계 중심 SQL, 데이터 웨어하우스/레이크하우스

## 5. 선택 가이드
- 워크로드 성격
  - 트랜잭션 중심(다수의 작은 읽기/쓰기, 낮은 레이턴시) → 행 기반
  - 분석 중심(대용량 스캔, 집계, 일부 컬럼만 사용) → 열 기반
- 쿼리 패턴
  - SELECT * 또는 개별 레코드 조회/갱신이 잦음 → 행 기반
  - 특정 컬럼들에 대한 필터/집계가 잦음 → 열 기반
- 데이터 적재 패턴
  - 실시간/점진 삽입, 잦은 업데이트/삭제 → 행 기반
  - 배치 적재와 주기적 컴팩션 가능 → 열 기반
- 비용/운영
  - 열 기반은 높은 압축률로 스토리지/스캔 비용 절감 가능(특히 클라우드 DWH 요금 체계)

## 6. 흔한 오해와 주의
- 열 기반은 "SELECT *" 같은 전체 컬럼 조회에는 불리할 수 있음(여러 컬럼 파일을 광범위하게 읽어야 함)
- 행 기반이라도 적절한 커버링 인덱스/분할/캐싱으로 분석 성능을 개선할 수 있고, 열 기반도 세심한 파티셔닝/클러스터링 설계가 필수
- HTAP(혼합형) 제품(SAP HANA, SingleStore 등)도 있으나, 일반적으로는 주 워크로드에 맞춘 전용 엔진을 선택하는 것이 안전

## 7. 대표 시스템 요약
- 행 기반: PostgreSQL, MySQL, MariaDB, Oracle, SQL Server
- 열 기반: BigQuery, Amazon Redshift, Snowflake, ClickHouse, Vertica, Apache Doris

## 8. 간단 비교 표

| 구분 | 행 기반(Row-oriented) | 열 기반(Column-oriented) |
|---|---|---|
| 저장 단위 | 행(레코드) | 컬럼 |
| 읽기 최적화 | 단건/소수 행 조회, SELECT * | 일부 컬럼 대량 스캔, 집계 |
| 쓰기/갱신 | 빠름(OLTP 친화) | 상대적으로 비효율, 배치/컴팩션 |
| I/O | 많은 컬럼 동시 로드 | 필요한 컬럼만 로드 → I/O 절감 |
| 압축 | 보통 | 높음(RLE/딕셔너리/델타 등) |
| 대표 제품 | PostgreSQL, MySQL 등 | BigQuery, Redshift, Snowflake 등 |

## 9. 예시로 본 차이
- 행 기반: [Atom, 2024-01-23] [Prin, 2024-02-01] [Gosmdochee, 2024-02-03]
- 열 기반: [Atom, Prin, Gosmdochee] [2024-01-23, 2024-02-01, 2024-02-03]

> 결론: 트랜잭션 처리 중심 서비스는 행 기반, 대규모 분석과 리포팅은 열 기반이 일반적으로 더 적합합니다. 워크로드에 맞춰 선택하세요.
