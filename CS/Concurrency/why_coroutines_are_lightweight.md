# 코루틴이 스레드보다 가벼운 이유: 컨텍스트 스위칭과 메모리 관점

## 1. 한 줄 요약
코루틴은 운영체제(OS)의 개입 없이 사용자 수준(User-Level)에서 컨텍스트 스위칭이 이루어지므로 스레드보다 훨씬 가볍고, 메모리 사용량이 적어 대규모 동시성 처리에 유리하다.

---

## 2. 문제의 핵심: 컨텍스트 스위칭 비용

전통적인 스레드(Thread)와 코루틴(Coroutine)의 가장 큰 차이는 **컨텍스트 스위칭(Context Switching)**을 누가 관리하느냐에 있다.

- **스레드**: OS 커널(Kernel)이 스케줄링을 담당한다. (커널 레벨 스레드 기준)
- **코루틴**: 프로그래밍 언어 런타임이나 프레임워크가 직접 스케줄링한다. (사용자 레벨)

이 차이가 "가벼움"의 핵심 원인이다.

---

## 3. 전통적인 스레드 방식의 특징과 한계

### 3-1. 비싼 컨텍스트 스위칭 비용
스레드 간의 컨텍스트 스위칭이 발생하면 다음과 같은 과정이 필요하다.

1.  **커널 모드 전환**: 현재 실행 중인 스레드를 멈추기 위해 유저 모드에서 커널 모드로 전환된다.
2.  **CPU 상태 저장**: 현재 스레드의 레지스터 값, 프로그램 카운터(PC) 등 CPU 상태를 해당 스레드의 TCB(Thread Control Block)에 저장한다.
3.  **스케줄링**: OS 스케줄러가 다음에 실행할 스레드를 선택한다.
4.  **CPU 상태 복원**: 새로 선택된 스레드의 TCB에서 CPU 상태를 읽어와 레지스터에 복원한다.
5.  **유저 모드 전환**: 다시 유저 모드로 돌아와 스레드 실행을 재개한다.

이 과정은 OS 커널의 개입이 필수적이므로 상당한 오버헤드를 유발한다. 이 때문에 스레드를 무한정 많이 생성하기 어렵다.

### 3-2. 높은 메모리 사용량
- 각 스레드는 독립적인 실행 흐름을 가지므로 자신만의 **스택(Stack) 메모리**를 할당받는다.
- Java 기준으로 스레드 하나당 기본적으로 약 1MB의 스택 메모리가 할당된다.
- 따라서 1,000개의 스레드를 생성하면 스택 메모리만으로 약 1GB의 메모리가 소모된다.

---

## 4. 코루틴 방식의 특징과 장점

### 4-1. 저렴한 컨텍스트 스위칭 비용
코루틴은 **협력적 멀티태스킹(Cooperative Multitasking)** 방식으로 동작하며, 컨텍스트 스위칭이 사용자 수준에서 일어난다.

1.  **OS 개입 없음**: I/O 대기 등 특정 지점(Suspension Point)에서 코루틴이 자발적으로 실행을 양보한다.
2.  **최소 정보만 저장**: 스위칭 시 필요한 최소한의 정보(예: 로컬 변수, 실행 지점)만 저장하고 다른 코루틴으로 전환한다.
3.  **단일 스레드 내에서 동작**: 여러 코루틴이 하나의 스레드(또는 소수의 스레드 풀) 위에서 동작하므로 커널 모드 전환이 발생하지 않는다.

이 과정은 단순한 함수 호출과 유사할 정도로 비용이 매우 저렴하다.

### 4-2. 적은 메모리 사용량
- 코루틴은 독립적인 스택을 갖지 않고, 기존 스레드의 스택이나 힙(Heap) 영역의 일부를 공유하여 사용한다.
- 필요한 데이터만 저장하므로 수십만, 수백만 개의 코루틴을 생성해도 메모리 부담이 적다. (예: Go의 고루틴은 초기 스택 크기가 2KB에 불과)

---

## 5. 스레드 vs. 코루틴 비교 요약

| 항목 | 스레드 (Thread) | 코루틴 (Coroutine) |
| --- | --- | --- |
| **관리 주체** | 운영체제 (OS Kernel) | 사용자 코드 / 런타임 |
| **스케줄링** | 선점형 (Preemptive) | 협력형 (Cooperative) |
| **컨텍스트 스위칭** | 비쌈 (커널 모드 전환 필요) | 저렴 (단순한 함수 호출 수준) |
| **메모리** | 독립적인 스택 (약 1MB/스레드) | 스택 공유 (수 KB/코루틴) |
| **생성 개수** | 수천 개 수준 | 수백만 개 이상 가능 |
| **동작 방식** | OS가 강제로 전환 | 자발적으로 양보 |
| **적합한 작업** | CPU 집약적 작업 (멀티코어 활용) | I/O 집약적 작업 (대기 시간 활용) |

---

## 6. 결론
코루틴은 **OS의 개입 없이 사용자 수준에서 스케줄링**되고, **독립적인 스택을 할당받지 않기 때문에** 스레드에 비해 컨텍스트 스위칭 비용과 메모리 사용량 측면에서 훨씬 "가볍다".

이러한 특성 덕분에 코루틴은 대규모 동시 연결을 처리해야 하는 I/O 집약적인 백엔드 서비스나 네트워크 애플리케이션에서 매우 효율적인 동시성 처리 모델로 각광받고 있다.
