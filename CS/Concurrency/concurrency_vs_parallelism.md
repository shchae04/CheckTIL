# 동시성과 병렬성 (Concurrency vs Parallelism)

## 1. 한 줄 요약
- 동시성(Concurrency): 여러 작업이 “동시에 진행되는 것처럼” 보이도록 조율하는 것(논리적 동시 실행). 단일 코어에서도 시간 분할과 컨텍스트 스위칭으로 구현 가능.
- 병렬성(Parallelism): 여러 작업을 “물리적으로 같은 시간에” 독립적으로 실행하는 것. 여러 코어/CPU에서 실제 동시 실행.

---

## 2. 개념 정리
### 동시성(Concurrency)이란?
- CPU가 I/O 대기(네트워크, 디스크, 사용자 입력 등)로 유휴 상태일 때 다른 작업으로 전환해 전체 처리량을 높이는 기법.
- 단일 코어에서도 스레드/코루틴 스케줄링과 컨텍스트 스위칭으로 다수의 작업을 번갈아 실행.
- 장점: I/O 바운드 워크로드에서 높은 자원 활용도, 여러 클라이언트 요청을 지연 없이 처리.
- 유의점: 다중 스레드/비동기 코드에서 동기화 이슈(데드락, 레이스 컨디션, 기아, 라이브락), 스케줄링/컨텍스트 스위칭 오버헤드.

### 병렬성(Parallelism)이란?
- 여러 코어가 각각 다른 작업을 동시에 수행해 실제로 같은 벽시각에 실행이 일어남.
- 주로 CPU 바운드 계산을 여러 하위 작업으로 쪼개 코어에 분산해 전체 완료 시간을 단축.
- 장점: 계산량 큰 작업의 처리 시간 단축에 효과적.
- 유의점: 공유 상태 동기화 비용, 캐시 적중률 저하, 오버헤드(쓰레드 생성/스케줄링)로 인해 기대 이득이 줄어들 수 있음. (암달의 법칙)

---

## 3. 백엔드 관점에서의 적용
### 3.1 I/O 바운드 요청 처리(네트워크/DB/파일)
- 전형적 웹 요청은 대기 시간이 길어 동시성 모델이 효과적.
  - 스레드-퍼-리퀘스트(예: Tomcat/Spring MVC): 요청당 스레드 할당, 블로킹 I/O. 적정한 스레드 풀 크기와 타임아웃이 중요.
  - 비동기/논블로킹(예: Netty, Spring WebFlux): 적은 스레드로 많은 동시 연결 처리. 이벤트 루프 기반, 백프레셔 지원.
- 팁: DB/Redis 드라이버도 논블로킹을 사용해야 진정한 논블로킹 경로를 확보 가능.

### 3.2 CPU 바운드 처리(인코딩, 해싱, 압축, 대량 직렬화 등)
- 병렬성으로 코어를 최대한 활용.
  - 워커 풀(executor)에서 작업을 분할하여 병렬 실행.
  - 공유 상태를 최소화하고 불변 데이터/순수 함수를 선호.
- 팁: CPU 바운드 풀 크기는 보통 코어 수(N) 또는 N+1 수준이 적합.

### 3.3 혼합 워크로드
- 한 요청 내에 I/O 대기와 CPU 연산이 혼재.
  - I/O 구간은 동시성(논블로킹)으로, CPU 구간은 별도 전용 풀에서 병렬 처리.
  - 이벤트 루프(reactor)에서 블로킹 호출 금지 → 필요 시 boundedElastic 같은 전용 풀로 오프로딩.

---

## 4. 주요 이슈와 대처
- Deadlock(교착): 순환 락 획득 → 고정된 락 순서, 타임아웃, 락 범위 최소화.
- Race Condition(경쟁 상태): 원자성/가시성 붕괴 → 불변 객체, 아토믹/락, 트랜잭션, 메시지 패싱.
- Starvation(기아): 우선순위/풀 구성 문제로 특정 작업이 기회 상실 → 공정한 큐잉, 적정 풀 크기.
- Livelock(활성 교착): 충돌 회피만 하다 진행 불가 → 랜덤 백오프, 재시도 정책.
- Oversubscription: 스레드 과다로 컨텍스트 스위칭 상승 → 풀 크기 제한, 블로킹 구간 단축.

---

## 5. 선택 가이드(요약)
- I/O 대기가 길고 동시 접속이 많다 → 동시성 중심(논블로킹, 이벤트 루프, 적절한 타임아웃/백프레셔).
- 연산이 무겁고 병렬화 가능하다 → 병렬성 중심(작업 분할, 공유 상태 최소화, 코어 수에 맞는 워커 풀).
- 서비스 안정성 우선 → 큐/비동기 처리로 스파이크 흡수, 백프레셔, 서킷브레이커.
- 운영 환경 고려 → 컨테이너 CPU 제한, 코어 수, 스레드 풀 상한, DB 커넥션 풀 크기 정합성 유지.

---

## 6. 실무 팁(주로 Java/Spring)
- 스레드 풀 사이징:
  - CPU 바운드: 풀 크기 ≈ 코어 수(N) 또는 N+1.
  - I/O 바운드: 풀 크기 ≈ N × (1 + 대기시간/서비스시간) 근사. 너무 큰 풀은 오히려 역효과.
- WebFlux/Netty: 이벤트 루프에서 블로킹 금지. 블로킹 I/O는 별도 bounded 풀로 오프로딩.
- DB/외부 API: 논블로킹 클라이언트 사용 시 진짜 논블로킹 경로 확보(예: R2DBC, WebClient).
- 불변/순수 함수: 공유 상태 최소화로 동기화 비용 절감.
- 백프레셔/재시도: 처리량 조절과 안정성 향상, 멱등성(idempotency) 고려.
- (옵션) 가상 스레드(Project Loom): 블로킹 코드 스타일과 높은 동시성을 양립. 풀 크기/블로킹 구간 설계를 단순화.

---

## 7. 간단 비교 요약
- 동시성: 논리적 동시에 진행, 단일 코어도 가능, I/O 바운드에 강점, 동기화 이슈 주의.
- 병렬성: 물리적 동시 실행(다중 코어), CPU 바운드에 강점, 동기화/캐시/오버헤드 주의.

---

## 8. 인터뷰 포인트(짧게)
- 정의: 동시성=여러 작업을 “잘” 다루는 것, 병렬성=여러 작업을 “진짜 동시에” 수행.
- 선택: I/O 바운드는 동시성(비동기/논블로킹), CPU 바운드는 병렬성(작업 분할·워커 풀).
- 주의: 데드락/레이스/기아 방지, 적정 스레드 풀·타임아웃·백프레셔.

---

## 9. 관련 문서
- 운영체제: ../OperatingSystems/process_thread_context_switching.md
- 데이터베이스: ../Database/database_concurrency_control.md
- 스프링 요청 흐름: ../../Interview/spring_request_flow.md
- WebClient 성능/비동기: ../../Interview/spring_boot_webclient_performance.md
