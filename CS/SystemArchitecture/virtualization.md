# 가상화(Virtualization)란?

## 1. 한 줄 정의
가상화는 하나의 물리적 컴퓨팅 리소스를 논리적으로 분리하여 여러 개의 독립적인 가상 리소스로 생성·운영하는 기술이다.

---

## 2. 가상화의 핵심 개념

### 2-1. 가상화의 정의
가상화(Virtualization)는 물리적인 하드웨어 리소스(서버, 스토리지, 네트워크 등)를 소프트웨어적으로 추상화하여 여러 개의 논리적인 가상 리소스로 분할·활용하는 기술을 의미한다.

### 2-2. 가상화 대상
- **서버 가상화**: 물리 서버를 여러 VM으로 분할
- **스토리지 가상화**: 물리적 저장소를 논리적 풀로 통합
- **네트워크 가상화**: 물리 네트워크를 논리적으로 분리
- **데스크톱 가상화**: 데스크톱 환경을 중앙에서 관리

---

## 3. 가상화가 필요한 이유

### 3-1. 리소스 효율성
물리 서버 하나에 여러 가상 서버를 배치하여 하드웨어 활용률을 극대화할 수 있다.

```
[물리 서버 1대]
├── VM 1: Web Server (CPU 20%, Memory 4GB)
├── VM 2: DB Server (CPU 30%, Memory 8GB)
└── VM 3: App Server (CPU 25%, Memory 6GB)
→ 총 활용률: CPU 75%, Memory 18GB
```

### 3-2. 비용 절감
- **초기 비용**: 물리 서버 구매 대수 감소
- **운영 비용**: 전력, 냉각, 공간 비용 절감
- **유지보수 비용**: 관리 대상 하드웨어 감소

### 3-3. 격리성(Isolation)
각 가상 리소스는 독립적으로 동작하여, 하나의 장애가 다른 리소스에 영향을 미치지 않는다.

```
VM 1 장애 발생 → VM 2, VM 3는 정상 동작
```

### 3-4. 유연성(Flexibility)
가상 리소스를 필요에 따라 빠르게 생성, 삭제, 이동할 수 있다.

```
새로운 테스트 환경이 필요할 때
→ 물리 서버 구매: 수일~수주 소요
→ VM 생성: 수분~수십분 소요
```

### 3-5. 가용성(Availability)
- 소프트웨어 기반이므로 스냅샷, 백업이 용이
- 다른 물리 서버로 빠른 이동(Live Migration) 가능
- 장애 복구 시간(RTO) 단축

---

## 4. 서버 가상화 상세

### 4-1. 서버 가상화의 개념
물리 서버를 여러 개의 가상 머신(VM, Virtual Machine)으로 나누어 사용하는 기술이다.

**주요 구성 요소**
- **호스트(Host)**: VM들이 실행되는 물리 서버
- **게스트(Guest)**: 물리 서버에서 실행되는 가상 머신(VM)
- **하이퍼바이저(Hypervisor)**: VM을 관리하는 가상화 소프트웨어

```
[물리 서버 - 호스트]
    ├── 하이퍼바이저
    │   ├── VM 1 (게스트) - Ubuntu Linux
    │   ├── VM 2 (게스트) - Windows Server
    │   └── VM 3 (게스트) - CentOS
    └── 물리 하드웨어 (CPU, Memory, Disk, Network)
```

### 4-2. 하이퍼바이저(Hypervisor)
물리 서버의 하드웨어 리소스를 VM에 할당하고, VM들을 격리·관리하는 가상화 소프트웨어다.

**하이퍼바이저의 주요 역할**
- CPU, 메모리, 디스크, 네트워크 리소스 할당
- VM 간 리소스 격리 및 보안 유지
- VM 스케줄링 및 리소스 최적화

### 4-3. 하이퍼바이저 유형

#### Type 1: Native/Bare Metal 하이퍼바이저
하드웨어에 직접 설치되어 실행되며, 별도의 호스트 OS가 필요 없다.

```
[VM 1] [VM 2] [VM 3]
   ↓      ↓      ↓
[하이퍼바이저 (Type 1)]
         ↓
  [물리 하드웨어]
```

**특징**
- 높은 성능 (호스트 OS 오버헤드 없음)
- 엔터프라이즈 데이터 센터에서 사용
- 안정성과 보안성이 우수

**예시**
- KVM (Kernel-based Virtual Machine)
- Microsoft Hyper-V
- VMware ESXi
- Xen

**사용 사례**
```
데이터 센터의 서버 가상화
- 수백 대의 VM을 물리 서버 10대로 통합
- 24/7 운영이 필요한 프로덕션 환경
```

#### Type 2: Hosted 하이퍼바이저
호스트 OS 위에서 하나의 애플리케이션처럼 실행된다.

```
[VM 1] [VM 2] [VM 3]
   ↓      ↓      ↓
[하이퍼바이저 (Type 2)]
         ↓
    [호스트 OS]
         ↓
  [물리 하드웨어]
```

**특징**
- 설치 및 사용이 간편
- 개인용 PC나 개발 환경에서 주로 사용
- 호스트 OS를 거치므로 성능은 Type 1보다 낮음

**예시**
- Oracle VirtualBox
- VMware Workstation
- Parallels Desktop

**사용 사례**
```
개발자 로컬 환경
- Windows PC에서 Linux 개발 환경 구축
- 다양한 OS 테스트 및 학습 목적
```

---

## 5. VM과 컨테이너 비교

### 5-1. VM (Virtual Machine)

**구조**
```
[애플리케이션] [애플리케이션] [애플리케이션]
      ↓              ↓              ↓
[게스트 OS 1]   [게스트 OS 2]   [게스트 OS 3]
      ↓              ↓              ↓
          [하이퍼바이저]
                ↓
           [호스트 OS]
                ↓
          [물리 하드웨어]
```

**특징**
- 각 VM이 독립적인 게스트 OS를 포함
- 높은 수준의 격리성
- 다양한 OS 실행 가능 (Windows, Linux 등)
- 무겁고 부팅이 느림 (분 단위)
- 리소스 오버헤드가 큼 (GB 단위)

### 5-2. 컨테이너 (Container)

**구조**
```
[애플리케이션] [애플리케이션] [애플리케이션]
      ↓              ↓              ↓
[컨테이너 1]    [컨테이너 2]    [컨테이너 3]
      ↓              ↓              ↓
     [컨테이너 런타임 (Docker, containerd)]
                ↓
           [호스트 OS]
                ↓
          [물리 하드웨어]
```

**특징**
- 호스트 OS의 커널을 공유
- 경량화 (MB 단위)
- 빠른 시작 시간 (초 단위)
- 높은 확장성
- 커널 공유로 인한 보안 취약점 가능성
- 호스트 OS와 동일한 계열 OS만 실행 가능

### 5-3. VM vs 컨테이너 상세 비교

| 특성 | VM | 컨테이너 |
|------|----|---------|
| **격리 수준** | 높음 (하드웨어 수준) | 중간 (프로세스 수준) |
| **부팅 시간** | 느림 (분 단위) | 빠름 (초 단위) |
| **리소스 사용** | 많음 (GB 단위) | 적음 (MB 단위) |
| **성능** | 낮음 (게스트 OS 오버헤드) | 높음 (네이티브에 가까움) |
| **OS 다양성** | 다양한 OS 실행 가능 | 호스트 OS와 동일 계열 |
| **이식성** | 중간 (하이퍼바이저 의존) | 높음 (컨테이너 이미지) |
| **확장성** | 낮음 | 높음 |
| **보안** | 강함 (완전 격리) | 약함 (커널 공유) |

---

## 6. 사용 사례 및 선택 기준

### 6-1. VM을 사용하는 경우

**사용 사례**
```
1. 다양한 OS가 필요한 환경
   - Windows Server + Linux 서버 동시 운영
   - 레거시 애플리케이션 (오래된 OS 버전 필요)

2. 높은 격리 수준이 중요한 경우
   - 멀티 테넌트 환경 (다수 고객의 독립적인 환경)
   - 보안이 중요한 금융, 의료 시스템

3. 전통적인 서버 통합
   - 기존 물리 서버를 가상화로 마이그레이션
   - 데이터 센터 서버 통합 프로젝트
```

**실무 예시**
```
금융사 시스템 가상화
- 물리 서버 100대를 VM 환경으로 통합
- 각 부서별로 독립된 VM 환경 제공
- 규제 요구사항 충족 (높은 격리 수준)
```

### 6-2. 컨테이너를 사용하는 경우

**사용 사례**
```
1. 마이크로서비스 아키텍처
   - 서비스별로 독립적인 컨테이너 배포
   - 서비스 단위 스케일링

2. 클라우드 네이티브 환경
   - Kubernetes 기반 오케스트레이션
   - 빠른 배포와 롤백

3. CI/CD 파이프라인
   - 빌드, 테스트 환경을 컨테이너로 구성
   - 일관된 개발/테스트/운영 환경

4. 빠른 확장이 필요한 경우
   - 트래픽 급증 시 Auto Scaling
   - 이벤트 기반 서비스 (서버리스)
```

**실무 예시**
```
E-commerce 마이크로서비스
- 주문 서비스: 10개 컨테이너
- 결제 서비스: 5개 컨테이너
- 상품 서비스: 8개 컨테이너
→ 트래픽에 따라 동적으로 컨테이너 수 조정
```

### 6-3. VM + 컨테이너 혼용

VM과 컨테이너는 대체 관계가 아니라 보완 관계다. 목적에 따라 함께 활용할 수 있다.

```
[클라우드 인프라 예시]

물리 서버
  ├── VM 1 (Kubernetes Master Node)
  │   ├── 컨테이너: API Server
  │   ├── 컨테이너: Scheduler
  │   └── 컨테이너: Controller Manager
  │
  ├── VM 2 (Kubernetes Worker Node 1)
  │   ├── 컨테이너: 주문 서비스 (3개)
  │   └── 컨테이너: 결제 서비스 (2개)
  │
  └── VM 3 (Kubernetes Worker Node 2)
      ├── 컨테이너: 상품 서비스 (4개)
      └── 컨테이너: 배송 서비스 (2개)
```

**장점**
- VM의 강력한 격리성 + 컨테이너의 유연성
- 인프라(VM) 단위 격리 + 애플리케이션(컨테이너) 단위 배포
- 보안과 성능의 균형

---

## 7. 백엔드 개발자 관점의 중요성

### 7-1. 인프라 이해
- **개발 환경**: 로컬에서 VM이나 컨테이너로 운영 환경 재현
- **배포 전략**: VM 기반 배포 vs 컨테이너 기반 배포 선택
- **리소스 최적화**: 애플리케이션의 리소스 요구사항 이해

### 7-2. 확장성 설계
- **수평 확장**: 컨테이너 기반 마이크로서비스로 스케일 아웃
- **수직 확장**: VM 리소스 증설로 스케일 업
- **Auto Scaling**: 트래픽에 따른 자동 확장 설계

### 7-3. 성능 최적화
- **VM 오버헤드**: 게스트 OS로 인한 성능 저하 고려
- **컨테이너 최적화**: 이미지 크기, 레이어 최적화
- **리소스 모니터링**: CPU, 메모리 사용률 추적

### 7-4. 보안 고려사항
- **VM 격리**: 민감한 데이터는 VM 수준 격리
- **컨테이너 보안**: 이미지 스캔, 런타임 보안 정책
- **네트워크 분리**: 가상 네트워크를 통한 세그먼테이션

### 7-5. DevOps 실무
```
개발 → 테스트 → 배포 파이프라인

1. 로컬 개발
   - Docker 컨테이너로 개발 환경 구성
   - MySQL, Redis 등을 컨테이너로 실행

2. CI/CD
   - Jenkins/GitLab CI에서 테스트용 컨테이너 실행
   - 빌드 아티팩트를 컨테이너 이미지로 생성

3. 스테이징
   - VM 기반 Kubernetes 클러스터
   - 컨테이너로 애플리케이션 배포

4. 프로덕션
   - VM 기반 고가용성 구성
   - 컨테이너 오케스트레이션으로 무중단 배포
```

---

## 8. 핵심 요약

### 8-1. 가상화 기술 비교

| 특성 | Type 1 하이퍼바이저 | Type 2 하이퍼바이저 | 컨테이너 |
|------|-------------------|-------------------|---------|
| **실행 위치** | 하드웨어 직접 | 호스트 OS 위 | 호스트 OS 커널 공유 |
| **성능** | 매우 높음 | 중간 | 가장 높음 |
| **격리 수준** | 매우 높음 | 높음 | 중간 |
| **부팅 시간** | 분 단위 | 분 단위 | 초 단위 |
| **리소스 효율** | 낮음 | 낮음 | 매우 높음 |
| **사용 환경** | 엔터프라이즈 | 개발/테스트 | 클라우드 네이티브 |

### 8-2. 선택 기준

**VM을 선택하는 경우**
-  다양한 OS가 필요할 때
-  높은 격리 수준이 필요할 때
-  레거시 애플리케이션 운영
-  규제 요구사항이 엄격한 산업

**컨테이너를 선택하는 경우**
-  마이크로서비스 아키텍처
-  빠른 배포와 확장이 필요할 때
-  CI/CD 파이프라인 구축
-  클라우드 네이티브 개발

**혼용하는 경우**
-  인프라 수준은 VM으로 격리
-  애플리케이션 수준은 컨테이너로 배포
-  보안과 유연성의 균형이 필요할 때

### 8-3. 실무 팁

**VM 운영 시**
- 리소스 오버 커밋(Over Commit) 주의 - 모든 VM이 동시에 최대 리소스를 사용하지 않도록 설계
- 스냅샷 활용 - 배포 전 스냅샷으로 빠른 롤백 가능
- Live Migration 활용 - 물리 서버 유지보수 시 VM 이동

**컨테이너 운영 시**
- 이미지 최적화 - Alpine Linux 등 경량 베이스 이미지 사용
- 레이어 캐싱 - Dockerfile 작성 순서 최적화
- 리소스 제한 - CPU, 메모리 Limit 설정으로 안정성 확보
- 오케스트레이션 활용 - Kubernetes로 자동화된 배포, 스케일링, 복구

**성능 모니터링**
- VM: 게스트 OS 리소스 + 하이퍼바이저 오버헤드
- 컨테이너: 호스트 OS 커널 메트릭 + 컨테이너별 리소스
- 병목 지점 파악 후 VM 또는 컨테이너 리소스 조정

### 8-4. 클라우드와 가상화

현대 클라우드 서비스는 가상화 기술 위에 구축된다:

```
AWS EC2 = VM 기반 인스턴스
AWS ECS/EKS = 컨테이너 오케스트레이션
AWS Lambda = 컨테이너 기반 서버리스

→ 클라우드를 이해하려면 가상화 개념이 필수
```

**백엔드 개발자가 알아야 할 이유**
- 인프라 선택과 비용 최적화
- 애플리케이션 아키텍처 설계
- 배포 전략 수립
- 장애 대응 및 복구 계획
