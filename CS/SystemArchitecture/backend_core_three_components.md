# 백엔드 개발을 위해 꼭 알아야 할 전체 구성

## 1) 한눈에 보기 (TL;DR)
- 백엔드의 핵심 목표는 “유저에게 데이터를 안정적으로, 빠르고, 정확하게 전달”하는 것이다.
- 이를 위해 역할이 분리된 3요소가 협업한다: 웹 서버(Web Server) → WAS(Web Application Server) → 데이터베이스(Database).
- 웹 서버는 정적 파일 전달과 프록시, WAS는 동적 로직 실행과 응답 생성, 데이터베이스는 영구 저장/동시성/무결성을 책임진다.
- 현대 프레임워크는 내장 WAS를 포함(예: Spring Boot의 내장 Tomcat, Node.js의 HTTP 스택)하여 WAS의 존재가 가려질 뿐, 개념은 여전히 유효하다.

---

## 2) 왜 중요한가: 핵심 철학
- 역할과 책임의 분리: 정적 파일 전달(웹 서버) / 동적 로직 실행(WAS) / 데이터 저장/일관성(DB).
- 역사적 진화: 정적 문서 공유 → 동적 상호작용 → 영구/안전한 데이터 관리의 필요성에 따른 분화.
- 다른 기술(모니터링, 로드밸런싱, 캐싱, CI/CD, 쿠버네티스 등)은 이 3요소의 이해 위에 쌓인다.

---

## 3) 백엔드의 3요소
1) 웹 서버(Web Server)
- 무엇을 하나? 정적 자원(HTML/CSS/JS/이미지) 고속 서빙, HTTP 연결 관리, 리버스 프록시/SSL 종료.
- 대표 기술: Nginx, Apache HTTPD, IIS, Caddy.

2) 웹 애플리케이션 서버(WAS)
- 무엇을 하나? 요청에 따라 코드를 실행해 동적 응답(HTML/JSON 등)을 생성하는 런타임 엔진.
- 프레임워크와의 관계: 프레임워크는 “설계도와 부품”, WAS는 “그걸 실제로 돌리는 엔진/런타임”.
- 대표 기술: (Java) Tomcat/Jetty, (Python) Gunicorn/Uvicorn, (JS) Node.js/Deno/Bun, (.NET) IIS.

3) 데이터베이스(Database)
- 무엇을 하나? 영구 저장, 동시성 제어(Lock), 트랜잭션(원자성/일관성), 인덱스로 고속 검색.
- 존재 이유: 파일 시스템만으론 동시성/무결성/성능을 보장하기 어렵기 때문.

---

## 4) 웹 서버 vs WAS 한눈에 비교
- 웹 서버: 항상 동일한 정적 페이지 반환, 고성능 정적 파일 서빙/프록시/SSL.
- WAS: 요청 파라미터/상태에 따라 동적 페이지/JSON 생성, 비즈니스 로직 실행.
- 현대 프레임워크: 내장 서버 제공으로 WAS가 눈에 덜 띄지만, 내부적으로는 동일한 역할 수행.

예시
- Spring Boot: main 실행 시 내장 Tomcat을 띄워 HTTP 패킷 파싱 → 컨트롤러로 전달.
- Express: Node.js가 TCP/HTTP 처리(WAS 역할) → Express는 라우팅/미들웨어.

---

## 5) 요소별 상세
### 5.1 웹 서버의 탄생과 역할
- 배경: WWW 초창기(1990s) 목적은 문서 공유. 요청이 오면 index.html 같은 정적 파일을 그대로 반환.
- 특징: 모든 사용자에게 동일한 콘텐츠(Static Web). 백엔드 개념이 희미하던 시기.
- 대표: Nginx, Apache, IIS, Caddy — 정적 서빙에 고도로 최적화.

### 5.2 WAS의 탄생과 역할
- 배경: 방문자 수 카운터, 사용자별 다른 페이지, 방명록 같은 “동적” 요구가 등장.
- 역할: HTTP 패킷 → Request 객체로 파싱 → 라우팅/컨트롤러 실행 → Response 생성 → HTTP 패킷으로 응답.
- 결론: 요청에 따라 코드를 실행하는 엔진이자 ‘진짜’ 백엔드의 시작.

### 5.3 데이터베이스의 탄생과 역할
- 배경: 서버 재시작 시 데이터 소실, 회원/재고/트랜잭션 등 영속성과 동시성/무결성 요구 증가.
- 파일 시스템의 한계: 동시성 제어 불가, 트랜잭션 부재, 대용량 검색 성능 저하.
- DB가 제공: Lock/Isolation, Transaction(원자성/일관성/격리/지속성), Index로 고속 조회.

---

## 6) 실제 협업 플로우(원트코딩 커뮤니티 예시)
1) 정적 파일 전송(홈 접속)
- 브라우저 → 도메인 접속.
- 웹 서버 → 정적 파일(HTML/CSS/JS) 전송.
- 브라우저 → 화면 렌더(아직 로그인/데이터 없음).

2) 로그인(API 요청)
- 프론트엔드 → POST /api/login로 아이디/비번 전송.
- 웹 서버 → API 프록시로 WAS에 전달.
- WAS → DB에서 사용자/비밀번호 검증 → JWT 발급 → 웹 서버 경유 응답.
- 브라우저/프론트엔드 → 토큰 저장 및 UI 업데이트.

3) 게시글 조회
- 프론트엔드 → GET /api/post/123 (JWT 포함).
- 웹 서버 → WAS로 전달.
- WAS → 토큰 검증, DB에서 게시글 조회 → JSON 응답 생성.
- 프론트엔드 → 화면 렌더.

---

## 7) 실무 체크리스트(Quick Checklist)
- [ ] 정적/동적 경계 설계: 무엇을 CDN/웹 서버에서, 무엇을 WAS에서 처리할지 분리했는가?
- [ ] 프록시/라우팅: API 프리픽스, 리버스 프록시, SSL 종료/리다이렉트 정책을 정의했는가?
- [ ] 프레임워크/WAS 이해: 내장 서버(예: 내장 Tomcat/Node HTTP)의 동작과 설정을 이해했는가?
- [ ] 데이터 무결성: 트랜잭션 경계/격리 수준/멱등성/중복 방지 키를 설계했는가?
- [ ] 동시성/경합: 락/낙관적 동시성/큐잉 등으로 경합을 제어하는가?
- [ ] 성능: 정적 자원 캐시/압축, DB 인덱스, 연결 풀/타임아웃, N+1 방지 등 설정을 갖췄는가?
- [ ] 보안: 인증/인가, 비밀관리, HTTPS 강제, 입력 검증, 토큰 저장 전략을 정의했는가?
- [ ] 관측 가능성: 로그/메트릭/트레이싱으로 웹 서버~WAS~DB 경로를 추적 가능한가?

---

## 8) 인터뷰 포인트
- 웹 서버와 WAS의 차이와 상호작용을 설명하라.
- 프레임워크(예: Spring/Django/Express)와 WAS의 관계를 설명하라.
- DB가 파일 시스템 대비 제공하는 핵심 가치(트랜잭션, 인덱스, 동시성 제어)를 사례와 함께 설명하라.
- 내장 WAS(예: Spring Boot)에서 main을 실행했을 때 내부적으로 무슨 일이 일어나는가?

---

## 9) 용어 요약
- 정적 웹(Static Web): 동일한 파일을 그대로 전달하는 방식.
- WAS: 요청에 따라 코드를 실행하고 동적 결과를 만들어내는 서버 런타임.
- 트랜잭션: 작업 단위를 하나로 묶어 ‘모두 성공 or 모두 실패’를 보장.
- 인덱스: 데이터 위치 정보를 별도로 유지해 고속 조회를 가능케 하는 구조.

---

## 10) 참고 및 관련 문서
- 배경 원문(요약 기반): 제공된 이슈 설명
- 관련: ./good_architecture_design.md
- LLM 기반 Query 시스템: ./llm_query_system.md
- LLM 대응 전략: ./llm_response_strategy.md
- 인터뷰/웹 흐름: ../../Interview/restful_api.md, ../../Interview/spring_request_flow.md
- DB 동시성: ../Database/database_concurrency_control.md
