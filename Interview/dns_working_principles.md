# DNS의 작동원리

DNS(Domain Name System)는 인터넷의 전화번호부와 같은 역할을 하는 시스템으로, 사람이 읽을 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 인식할 수 있는 IP 주소(예: 192.0.2.1)로 변환해주는 핵심 인터넷 인프라입니다.

## 1. DNS의 필요성

인터넷 상의 모든 장치는 IP 주소를 통해 통신합니다. 그러나 사람이 숫자로 된 IP 주소를 모두 기억하는 것은 어렵습니다. DNS는 다음과 같은 이유로 필요합니다:

- **사용자 편의성**: 복잡한 IP 주소 대신 의미 있는 도메인 이름을 사용할 수 있습니다.
- **IP 주소 변경 유연성**: 서버의 IP 주소가 변경되어도 도메인 이름은 그대로 유지할 수 있습니다.
- **로드 밸런싱**: 하나의 도메인 이름으로 여러 IP 주소를 연결하여 부하를 분산할 수 있습니다.

## 2. DNS 계층 구조

DNS는 분산 데이터베이스 시스템으로, 계층적 구조를 가지고 있습니다. 이 계층 구조는 도메인 이름 공간을 효율적으로 관리하고 확장성을 제공합니다.

### DNS 계층 구조 상세 비교

| 계층 | 역할 | 특징 | 예시 | 관리 주체 |
|------|------|------|------|----------|
| **루트 DNS 서버** | DNS 계층 구조의 최상위 서버 | 전 세계 13개 그룹(A-M) 존재 | `.` (루트 도메인) | ICANN(Internet Corporation for Assigned Names and Numbers) |
| **TLD DNS 서버** | 최상위 도메인 관리 | gTLD와 ccTLD로 구분 | `.com`, `.org`, `.net`, `.kr` | ICANN 위임 기관(Verisign 등) |
| **권한 있는 DNS 서버** | 특정 도메인의 DNS 레코드 관리 | 실제 도메인-IP 매핑 정보 보유 | `example.com`의 DNS 서버 | 도메인 등록 기관, 호스팅 제공업체 |
| **로컬 DNS 서버** | 사용자 DNS 쿼리 처리 | 재귀적 조회 수행 및 결과 캐싱 | ISP DNS 서버, Google DNS(8.8.8.8) | ISP, 조직, 공용 DNS 제공업체 |

### 도메인 이름 계층 구조

```
                      루트(.)
                        |
        +---------------+---------------+
        |               |               |
      .com            .org             .kr
        |               |               |
    +---+---+       +---+---+       +---+---+
    |       |       |       |       |       |
example  google   mozilla   w3c    kisa    seoul
    |
+---+---+
|       |
www    mail
```

### 1) 루트 DNS 서버 (Root DNS Servers)
- DNS 계층 구조의 최상위에 위치하며, 모든 DNS 조회의 시작점
- 전 세계에 13개의 루트 서버 그룹(A부터 M까지)이 존재하며, 각 그룹은 여러 서버로 구성된 애니캐스트 네트워크로 운영
- TLD DNS 서버의 정보를 관리하고, DNS 조회 과정에서 TLD 서버로 안내하는 역할

### 2) 최상위 도메인 DNS 서버 (TLD DNS Servers)
- 최상위 도메인(TLD)은 크게 일반 최상위 도메인(gTLD)과 국가 코드 최상위 도메인(ccTLD)으로 구분
  * **gTLD**: .com, .org, .net, .edu, .gov 등
  * **ccTLD**: .kr(한국), .jp(일본), .us(미국) 등
- 해당 TLD에 등록된 도메인의 권한 있는 DNS 서버 정보를 제공
- 각 TLD는 ICANN에서 위임한 기관(레지스트리)에서 관리

### 3) 권한 있는 DNS 서버 (Authoritative DNS Servers)
- 특정 도메인에 대한 실제 DNS 레코드(A, AAAA, MX, CNAME 등)를 보유
- 도메인 등록 기관(레지스트라)이나 호스팅 제공업체가 관리
- 최종적으로 도메인 이름을 IP 주소로 변환하는 정보를 제공

### 4) 로컬 DNS 서버 (Local DNS Servers / Recursive Resolvers)
- ISP나 조직에서 운영하는 DNS 서버로, 사용자의 DNS 쿼리를 직접 받는 첫 번째 서버
- 사용자를 대신하여 재귀적 DNS 조회를 수행하고 결과를 캐싱
- 대표적인 공용 DNS 서버: Google DNS(8.8.8.8), Cloudflare DNS(1.1.1.1), Quad9(9.9.9.9)

## 3. DNS 조회 과정

DNS 조회는 도메인 이름을 IP 주소로 변환하는 과정으로, 여러 단계와 서버 간의 상호작용을 포함합니다.

### DNS 쿼리 유형 비교

| 특성 | 반복적 쿼리 (Iterative Query) | 재귀적 쿼리 (Recursive Query) |
|------|---------------------------|---------------------------|
| **정의** | DNS 서버가 알고 있는 정보만 제공하고, 다음 서버를 안내 | DNS 서버가 전체 조회 과정을 대신 수행하고 최종 결과 반환 |
| **주요 사용자** | DNS 서버 간 통신 | 클라이언트와 로컬 DNS 서버 간 통신 |
| **응답 유형** | 부분적 응답 (다음 문의할 서버 정보) | 완전한 응답 (최종 IP 주소) |
| **서버 부하** | 낮음 (각 서버는 자신이 알고 있는 정보만 제공) | 높음 (로컬 DNS 서버가 모든 조회 과정 수행) |
| **클라이언트 부담** | 높음 (여러 서버에 직접 쿼리) | 낮음 (한 번의 쿼리로 결과 획득) |
| **보안 위험** | 상대적으로 낮음 | 캐시 포이즈닝 등의 위험 존재 |
| **네트워크 트래픽** | 많음 (여러 쿼리 필요) | 적음 (클라이언트 관점에서) |

### DNS 조회 과정 상세 흐름도

```
+-------------+    1. 도메인 조회 요청     +----------------+
| 클라이언트   | -------------------------> | 로컬 DNS 서버  |
| (브라우저)   | <------------------------- | (리커서)       |
+-------------+    8. IP 주소 반환         +----------------+
                                                  |
                                                  | 2. 루트 DNS 서버에 쿼리
                                                  v
                                           +----------------+
                                           | 루트 DNS 서버  |
                                           +----------------+
                                                  |
                                                  | 3. TLD 서버 정보 반환
                                                  v
                                           +----------------+
                                           | TLD DNS 서버   |
                                           +----------------+
                                                  |
                                                  | 4. 권한 있는 DNS 서버 정보 반환
                                                  v
                                           +----------------+
                                           | 권한 있는      |
                                           | DNS 서버       |
                                           +----------------+
                                                  |
                                                  | 5. IP 주소 정보 반환
                                                  v
                                           +----------------+
                                           | 로컬 DNS 서버  |
                                           | (결과 캐싱)    |
                                           +----------------+
```

### 1) DNS 조회 단계별 상세 과정

1. **브라우저 캐시 확인**:
   - 브라우저는 먼저 자체 캐시에서 도메인 이름에 대한 IP 주소를 찾습니다.
   - Chrome의 경우 `chrome://net-internals/#dns`에서 DNS 캐시를 확인할 수 있습니다.

2. **OS 캐시 확인**:
   - 브라우저 캐시에 없으면 운영체제의 DNS 캐시를 확인합니다.
   - Windows: `ipconfig /displaydns` 명령으로 확인 가능
   - Linux/Mac: `nscd` (Name Service Cache Daemon)에 저장

3. **로컬 DNS 서버 쿼리**:
   - OS 캐시에도 없으면 로컬 DNS 서버(일반적으로 ISP가 제공)에 쿼리를 보냅니다.
   - `/etc/resolv.conf` 파일에 설정된 DNS 서버 주소 사용

4. **DNS 조회 과정 (로컬 DNS 서버가 수행)**:
   - **루트 DNS 서버 쿼리**: 루트 DNS 서버에 쿼리를 보내 TLD 서버 정보를 얻습니다.
   - **TLD DNS 서버 쿼리**: TLD DNS 서버에 쿼리를 보내 권한 있는 DNS 서버 정보를 얻습니다.
   - **권한 있는 DNS 서버 쿼리**: 권한 있는 DNS 서버에 쿼리를 보내 최종 IP 주소를 얻습니다.

5. **결과 반환 및 캐싱**:
   - 로컬 DNS 서버는 얻은 IP 주소를 클라이언트에게 반환합니다.
   - 이 정보는 TTL(Time To Live) 값에 따라 일정 시간 동안 캐싱됩니다.

### 2) 반복적 쿼리 vs 재귀적 쿼리

#### 반복적 쿼리 (Iterative Query)
로컬 DNS 서버가 다른 DNS 서버에 쿼리를 보낼 때, 해당 서버는 자신이 알고 있는 정보만 제공하고 다음에 문의할 서버 정보를 알려줍니다. 로컬 DNS 서버는 이 정보를 바탕으로 다음 서버에 직접 쿼리를 보냅니다.

#### 재귀적 쿼리 (Recursive Query)
클라이언트가 로컬 DNS 서버에 쿼리를 보내면, 로컬 DNS 서버가 전체 조회 과정을 대신 수행하고 최종 결과만 클라이언트에게 반환합니다. 클라이언트는 한 번의 쿼리로 결과를 얻을 수 있어 편리합니다.

### 3) 실제 DNS 조회 예시: www.example.com

1. 사용자가 브라우저에 "www.example.com" 입력
2. 브라우저는 로컬 DNS 서버에 "www.example.com의 IP 주소는?" 쿼리
3. 로컬 DNS 서버는 루트 DNS 서버에 쿼리
4. 루트 DNS 서버는 ".com" TLD 서버 정보 제공
5. 로컬 DNS 서버는 ".com" TLD 서버에 쿼리
6. ".com" TLD 서버는 "example.com" 권한 있는 DNS 서버 정보 제공
7. 로컬 DNS 서버는 "example.com" 권한 있는 DNS 서버에 쿼리
8. "example.com" 권한 있는 DNS 서버는 "www.example.com"의 IP 주소 제공
9. 로컬 DNS 서버는 이 IP 주소를 사용자의 브라우저에 반환

## 4. DNS 레코드 유형

DNS 서버는 다양한 유형의 레코드를 저장하며, 각 레코드 유형은 특정 목적을 위해 설계되었습니다.

### 주요 DNS 레코드 유형 상세 비교

| 레코드 유형 | 설명 | 예시 | 일반적인 TTL | 주요 용도 |
|------------|------|------|------------|----------|
| **A (Address)** | 도메인 이름을 IPv4 주소로 매핑 | example.com → 192.0.2.1 | 300-86400초 | 웹사이트, 서버 호스팅 |
| **AAAA (IPv6 Address)** | 도메인 이름을 IPv6 주소로 매핑 | example.com → 2001:0db8:85a3::8a2e:0370:7334 | 300-86400초 | IPv6 지원 서비스 |
| **CNAME (Canonical Name)** | 도메인의 별칭 설정 | www.example.com → example.com | 300-86400초 | 서브도메인, CDN 연동 |
| **MX (Mail Exchange)** | 이메일 서버 지정 | example.com → mail.example.com (우선순위: 10) | 3600-86400초 | 이메일 서비스 |
| **NS (Name Server)** | 도메인의 DNS 서버 지정 | example.com → ns1.example.com | 86400초 이상 | DNS 서버 위임 |
| **TXT (Text)** | 텍스트 정보 저장 | example.com → "v=spf1 include:_spf.example.com ~all" | 300-86400초 | SPF, DKIM, 도메인 검증 |
| **SOA (Start of Authority)** | 도메인의 권한 정보 | example.com → ns1.example.com admin.example.com (시리얼: 2023121501) | 86400초 이상 | 영역 관리 정보 |
| **PTR (Pointer)** | IP 주소를 도메인 이름으로 역변환 | 192.0.2.1 → example.com | 86400초 이상 | 역방향 DNS 조회 |
| **SRV (Service)** | 특정 서비스의 위치 지정 | _sip._tcp.example.com → sip.example.com:5060 | 3600초 | VoIP, XMPP, Active Directory |
| **CAA (Certification Authority Authorization)** | 인증서 발급 기관 제한 | example.com → 0 issue "letsencrypt.org" | 86400초 | SSL/TLS 인증서 보안 |

### DNS 레코드 예시 및 사용 사례

#### 웹사이트 호스팅 설정 예시
```
# 기본 도메인 설정
example.com.     IN    A       192.0.2.1
example.com.     IN    AAAA    2001:0db8:85a3::1

# www 서브도메인 설정 (CNAME 사용)
www.example.com. IN    CNAME   example.com.

# 메일 서버 설정
example.com.     IN    MX      10 mail.example.com.
mail.example.com. IN   A       192.0.2.2

# SPF 레코드 (이메일 스푸핑 방지)
example.com.     IN    TXT     "v=spf1 ip4:192.0.2.0/24 include:_spf.example.com ~all"

# DKIM 레코드 (이메일 인증)
selector._domainkey.example.com. IN TXT "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC..."
```

#### 특수 레코드 활용 사례

| 활용 사례 | 사용 레코드 | 설정 예시 | 설명 |
|----------|------------|----------|------|
| **이메일 보안** | SPF, DKIM, DMARC (TXT) | `v=spf1 ip4:192.0.2.0/24 ~all` | 이메일 스푸핑 방지 및 인증 |
| **서비스 검색** | SRV | `_sip._tcp.example.com. 86400 IN SRV 10 60 5060 sip.example.com.` | VoIP 서버 위치 지정 |
| **로드 밸런싱** | 다중 A/AAAA | 여러 IP 주소를 동일 도메인에 설정 | 트래픽 분산 |
| **지리적 라우팅** | GeoDNS | 위치에 따라 다른 IP 반환 | 가까운 서버로 연결 |
| **CDN 연동** | CNAME | `www.example.com. IN CNAME cdn.provider.com.` | 콘텐츠 전송 네트워크 연결 |
| **인증서 보안** | CAA | `example.com. IN CAA 0 issue "letsencrypt.org"` | 인증서 발급 기관 제한 |

## 5. DNS 캐싱

DNS 조회는 상당한 시간이 소요될 수 있으므로, 성능 향상을 위해 여러 계층에서 캐싱이 이루어집니다. 캐싱은 DNS 쿼리 응답 시간을 단축하고 DNS 서버의 부하를 줄이는 중요한 메커니즘입니다.

### DNS 캐싱 계층 구조

| 캐싱 계층 | 설명 | 일반적인 캐시 유지 시간 | 확인/관리 방법 |
|----------|------|-------------------|--------------|
| **브라우저 DNS 캐시** | 브라우저가 이전에 조회한 도메인 정보를 저장 | 수 분~수 시간 | Chrome: `chrome://net-internals/#dns`<br>Firefox: `about:networking#dns` |
| **OS DNS 캐시** | 운영체제 수준에서 DNS 조회 결과를 캐싱 | TTL 값에 따라 다름 | Windows: `ipconfig /displaydns`<br>Linux: `systemd-resolve --statistics`<br>Mac: `sudo dscacheutil -flushcache` |
| **로컬 DNS 서버 캐시** | ISP나 조직의 DNS 서버가 조회 결과를 캐싱 | TTL 값에 따라 다름 (일반적으로 수 분~수 일) | 서버 로그 또는 관리 인터페이스 |
| **권한 있는 DNS 서버 캐시** | 상위 DNS 서버의 정보를 캐싱 | 구성에 따라 다름 (일반적으로 수 시간~수 일) | DNS 서버 관리 도구 |

### TTL(Time To Live)과 캐싱 전략

TTL은 DNS 레코드가 캐시에 얼마나 오래 유지될지 결정하는 값으로, 초 단위로 지정됩니다. 각 DNS 레코드는 자체 TTL 값을 가지며, 이 시간이 지나면 캐시에서 만료되고 새로운 조회가 필요합니다.

#### 레코드 유형별 일반적인 TTL 값과 권장 설정

| 레코드 유형 | 일반적인 TTL | 변경 빈도가 높을 때 | 변경 빈도가 낮을 때 | 권장 사항 |
|------------|------------|-----------------|-----------------|----------|
| **A/AAAA** | 300-3600초 | 60-300초 | 3600-86400초 | 서버 IP가 자주 변경되면 짧게, 안정적이면 길게 설정 |
| **CNAME** | 300-3600초 | 300-900초 | 3600-86400초 | CDN 사용 시 적절한 값으로 설정 |
| **MX** | 3600-86400초 | 900-3600초 | 86400초 | 메일 서버는 자주 변경되지 않으므로 길게 설정 |
| **NS** | 86400초 이상 | 3600-43200초 | 86400-172800초 | DNS 서버 변경은 드물므로 길게 설정 |
| **TXT** | 300-3600초 | 60-900초 | 3600-86400초 | SPF/DKIM 등 보안 레코드는 적절히 설정 |
| **SOA** | 86400초 이상 | 3600-43200초 | 86400-172800초 | 영역 관리 정보는 길게 설정 |

### DNS 캐싱의 장단점

#### 장점
- **응답 시간 단축**: 캐싱된 결과를 즉시 반환하여 DNS 조회 시간 단축
- **네트워크 트래픽 감소**: 반복적인 DNS 쿼리 감소로 네트워크 부하 감소
- **DNS 서버 부하 분산**: 모든 쿼리가 권한 있는 DNS 서버에 도달하지 않음
- **인터넷 안정성 향상**: 일시적인 DNS 서버 장애 시에도 캐시된 정보로 서비스 유지

#### 단점
- **변경 전파 지연**: DNS 레코드 변경 시 TTL 값만큼 전파 지연 발생
- **캐시 불일치**: 서로 다른 캐시 계층에 다른 정보가 저장될 수 있음
- **캐시 포이즈닝 위험**: 악의적인 DNS 정보가 캐싱될 경우 보안 위험

### DNS 캐싱 관리 전략

1. **TTL 값 최적화**:
   - 일반적인 운영: 높은 TTL 값 (3600-86400초)
   - 예정된 변경 전: 낮은 TTL 값으로 변경 (300-900초)
   - 변경 후: 다시 높은 TTL 값으로 복원

2. **DNS 캐시 플러싱**:
   - 브라우저: 개발자 도구 또는 브라우저 재시작
   - OS: 명령어를 통한 DNS 캐시 초기화
   - 로컬 DNS 서버: 서버 재시작 또는 관리 명령어

3. **DNS 변경 계획**:
   - 중요한 변경 전 TTL 값을 낮게 설정하고 충분한 시간 대기
   - 변경 작업은 트래픽이 적은 시간에 수행
   - 변경 후 모니터링을 통해 전파 확인

## 6. DNS 보안 이슈

DNS는 인터넷의 핵심 인프라로서 다양한 보안 위협에 노출되어 있습니다. 이러한 위협은 사용자를 피싱 사이트로 유도하거나, 서비스 거부 공격에 악용되거나, 통신을 도청하는 등 심각한 보안 문제를 일으킬 수 있습니다.

### DNS 공격 유형 및 대응 방안 비교

| 공격 유형 | 설명 | 공격 방식 | 영향 범위 | 주요 대응 방안 | 구현 난이도 |
|----------|------|----------|----------|--------------|------------|
| **DNS 스푸핑<br>(DNS Spoofing)** | 공격자가 DNS 응답을 가로채거나 위조하여 사용자를 악성 사이트로 리디렉션 | 중간자 공격, 패킷 인터셉트 | 특정 사용자 또는 네트워크 | DNSSEC, DNS over HTTPS/TLS | 중간 |
| **DNS 캐시 포이즈닝<br>(Cache Poisoning)** | DNS 서버의 캐시에 잘못된 정보를 주입하여 대규모 사용자에게 영향 | 위조된 DNS 응답 전송, 생일 공격 | 캐시 서버를 사용하는 모든 사용자 | DNSSEC, DNS 쿼리 ID/포트 랜덤화 | 높음 |
| **DNS 증폭 공격<br>(Amplification Attack)** | DNS 서버를 이용한 DDoS 공격으로, 작은 쿼리로 큰 응답을 유발 | 소스 IP 스푸핑, ANY 쿼리 | 대상 서버 및 네트워크 | RRL(Response Rate Limiting), ANY 쿼리 차단 | 낮음 |
| **DNS 터널링<br>(DNS Tunneling)** | DNS 프로토콜을 통해 데이터를 은밀히 전송하는 기법 | 도메인 이름에 데이터 인코딩 | 데이터 유출, 악성코드 통신 | DNS 트래픽 분석, 이상 탐지 | 중간 |
| **DNS 하이재킹<br>(DNS Hijacking)** | DNS 설정을 변경하여 트래픽을 악성 서버로 리디렉션 | 라우터 설정 변경, 악성코드 | 특정 네트워크 또는 장치 | DNSSEC, DNS 설정 모니터링 | 중간 |
| **도메인 탈취<br>(Domain Hijacking)** | 도메인 등록 정보를 변경하여 도메인 소유권 탈취 | 사회공학, 등록기관 해킹 | 특정 도메인 및 서비스 | 레지스트라 잠금, 2FA 인증 | 높음 |
| **랜덤 서브도메인 공격<br>(Random Subdomain Attack)** | 무작위 서브도메인 쿼리로 DNS 서버 과부하 유발 | 대량의 무작위 서브도메인 쿼리 | DNS 서버 및 서비스 | 쿼리 속도 제한, 패턴 탐지 | 낮음 |

### DNS 보안 강화 기술

#### 1) DNSSEC (DNS Security Extensions)
DNSSEC는 디지털 서명을 사용하여 DNS 데이터의 무결성과 출처를 검증하는 보안 확장 기능입니다.

**작동 원리**:
- DNS 레코드에 공개 키 암호화 기반 디지털 서명 추가
- 신뢰 체인(Chain of Trust)을 통한 검증
- 루트 영역부터 하위 영역까지 연결된 신뢰 구조

**주요 레코드 유형**:
- **DNSKEY**: 영역의 공개 키
- **RRSIG**: 리소스 레코드 세트의 디지털 서명
- **DS**: 하위 영역의 키에 대한 해시(상위 영역에 저장)
- **NSEC/NSEC3**: 존재하지 않는 이름에 대한 인증된 부정 응답

**장단점**:
- **장점**: DNS 스푸핑 및 캐시 포이즈닝 방지, 데이터 무결성 보장
- **단점**: 구현 복잡성, 대역폭 및 처리 오버헤드 증가, 키 관리 부담

#### 2) DNS over HTTPS/TLS (DoH/DoT)
DNS 쿼리를 암호화하여 프라이버시를 보호하고 중간자 공격을 방지하는 기술입니다.

**구현 방식**:
- **DNS over HTTPS (DoH)**: HTTPS 프로토콜을 통해 DNS 쿼리 전송 (포트 443)
- **DNS over TLS (DoT)**: TLS 프로토콜을 통해 DNS 쿼리 전송 (포트 853)

#### 3) DNS 방화벽 및 필터링
악성 도메인 접근을 차단하고 DNS 트래픽을 모니터링하는 보안 솔루션입니다.

**주요 기능**:
- 악성 도메인 및 피싱 사이트 차단
- 데이터 유출 방지를 위한 DNS 트래픽 분석
- 의심스러운 DNS 활동 탐지 및 알림

### DNS 보안 모범 사례

1. **DNS 서버 보안 강화**:
   - DNS 소프트웨어 최신 버전 유지
   - 불필요한 DNS 쿼리 유형 제한
   - 영역 전송(Zone Transfer) 제한

2. **모니터링 및 감사**:
   - DNS 트래픽 모니터링 및 이상 탐지
   - DNS 설정 변경 감사 및 알림
   - DNS 응답 시간 및 성능 모니터링

3. **중복성 및 분산**:
   - 다중 DNS 서버 구성
   - 지리적으로 분산된 DNS 인프라
   - 다양한 DNS 제공업체 활용

## 7. 최신 DNS 기술

인터넷의 발전과 함께 DNS 기술도 지속적으로 진화하고 있습니다. 최신 DNS 기술은 보안, 프라이버시, 성능 및 확장성을 개선하는 데 중점을 두고 있습니다.

### 현대 DNS 프로토콜 비교

| 프로토콜 | 전송 방식 | 기본 포트 | 암호화 | 주요 장점 | 주요 단점 | 지원 현황 |
|---------|----------|----------|-------|----------|----------|----------|
| **기존 DNS** | UDP/TCP | 53 | 없음 | 단순함, 광범위한 지원 | 프라이버시 취약, 중간자 공격 위험 | 모든 시스템 |
| **DNS over HTTPS<br>(DoH)** | HTTPS | 443 | TLS 1.2/1.3 | 방화벽 우회 가능, 웹 트래픽과 혼합 | 트래픽 분석 어려움, 중앙화 우려 | 주요 브라우저, 일부 OS |
| **DNS over TLS<br>(DoT)** | TLS | 853 | TLS 1.2/1.3 | 전용 포트로 관리 용이, 표준화 | 방화벽에서 차단 가능 | 일부 OS, 일부 DNS 제공업체 |
| **DNSCrypt** | 사용자 정의 | 443/5353 | DNSCrypt | 경량, 인증 지원 | 표준화 부족 | 일부 클라이언트, 일부 DNS 제공업체 |
| **DNS over QUIC<br>(DoQ)** | QUIC | 784 | TLS 1.3 | 연결 지연 감소, HOL 차단 문제 해결 | 신규 기술, 제한적 지원 | 실험 단계 |
| **Oblivious DNS<br>(ODoH)** | HTTPS | 443 | TLS 1.3 | 프록시 사용으로 프라이버시 강화 | 복잡성 증가, 지연 시간 증가 | 실험 단계 |

### 주요 최신 DNS 기술 상세 설명

#### 1) DNS over HTTPS (DoH)
HTTPS 프로토콜을 통해 DNS 쿼리를 암호화하여 전송하는 기술입니다.

**주요 특징**:
- 웹 브라우저에서 직접 지원 (Chrome, Firefox, Edge 등)
- 일반 HTTPS 트래픽과 구분하기 어려워 검열 우회 가능
- JSON 또는 DNS 와이어 포맷으로 쿼리 전송
- RFC 8484로 표준화

**구현 예시**:
```
https://dns.google/dns-query?dns=AAABAAABAAAAAAAAA3d3dwdleGFtcGxlA2NvbQAAAQAB
```

**주요 제공업체**:
- Google (8.8.8.8) - `https://dns.google/dns-query`
- Cloudflare (1.1.1.1) - `https://cloudflare-dns.com/dns-query`
- Quad9 (9.9.9.9) - `https://dns.quad9.net/dns-query`

#### 2) DNS over TLS (DoT)
TLS 프로토콜을 통해 DNS 쿼리를 암호화하여 전송하는 기술입니다.

**주요 특징**:
- 전용 포트(853)를 사용하여 트래픽 관리 용이
- Android 9 이상에서 기본 지원
- RFC 7858로 표준화
- 연결 지속성으로 성능 향상

**구현 방식**:
- 클라이언트는 DNS 서버와 TLS 핸드셰이크 수행
- 암호화된 연결을 통해 표준 DNS 쿼리 전송
- 서버 인증서 검증으로 서버 신원 확인

**설정 예시** (Linux systemd-resolved):
```
[Resolve]
DNS=1.1.1.1
DNSOverTLS=yes
```

#### 3) EDNS (Extension Mechanisms for DNS)
기존 DNS 프로토콜의 기능을 확장하는 메커니즘입니다.

**주요 기능**:
- **EDNS0 (RFC 6891)**: 기본 확장 메커니즘
  * 더 큰 UDP 패킷 크기 지원 (512바이트 → 4096바이트)
  * 추가 플래그 및 옵션 코드 제공
  * DNS 쿼리/응답에 메타데이터 추가 가능

- **EDNS Client Subnet (ECS)**: 
  * 클라이언트의 서브넷 정보를 DNS 쿼리에 포함
  * 지리적으로 최적화된 응답 제공 (CDN 등에 유용)
  * 프라이버시 우려로 논란 있음

- **EDNS Cookie**: 
  * 서버와 클라이언트 간 쿠키 교환으로 DNS 증폭 공격 방지
  * 재귀적 DNS 서버 보호에 효과적

#### 4) DNS64/NAT64
IPv6 전용 네트워크에서 IPv4 리소스에 접근할 수 있게 하는 기술입니다.

**작동 원리**:
- DNS64: IPv4 전용 도메인에 대해 합성된 AAAA 레코드 제공
- NAT64: IPv6 패킷을 IPv4 패킷으로 변환하는 게이트웨이

**사용 사례**:
- IPv6 전용 모바일 네트워크
- IPv6로 전환 중인 기업 네트워크

#### 5) Multi-CDN DNS
여러 CDN 제공업체를 활용하여 최적의 성능과 가용성을 제공하는 DNS 기반 기술입니다.

**주요 기능**:
- 실시간 성능 모니터링 기반 CDN 선택
- 지리적 위치, 비용, 트래픽 부하 등 고려
- 장애 자동 감지 및 대체 경로 제공

### DNS 기술의 미래 전망

1. **분산형 DNS**:
   - 블록체인 기반 DNS 시스템
   - 중앙화된 관리 구조 탈피
   - 검열 저항성 강화

2. **AI 기반 DNS**:
   - 머신러닝을 활용한 DNS 트래픽 분석
   - 이상 탐지 및 보안 위협 예측
   - 자동화된 최적화 및 조정

3. **IoT를 위한 경량 DNS**:
   - 제한된 리소스 환경에 최적화
   - 낮은 지연 시간 및 전력 소비
   - 대규모 장치 관리를 위한 확장성

## 결론

DNS는 인터넷의 핵심 인프라로, 사용자 친화적인 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 중요한 역할을 합니다. 계층적 구조와 분산 데이터베이스 시스템을 통해 확장성과 신뢰성을 제공하며, 다양한 캐싱 메커니즘으로 성능을 최적화합니다. 최근에는 보안과 프라이버시를 강화하기 위한 다양한 기술이 도입되고 있습니다.

DNS의 작동 원리를 이해하는 것은 웹 개발자, 시스템 관리자, 네트워크 엔지니어에게 필수적인 지식이며, 인터넷이 어떻게 작동하는지 이해하는 데 중요한 기반이 됩니다.

## 참고 자료
- [RFC 1034: Domain Names - Concepts and Facilities](https://tools.ietf.org/html/rfc1034)
- [RFC 1035: Domain Names - Implementation and Specification](https://tools.ietf.org/html/rfc1035)
- [Cloudflare: DNS란 무엇입니까?](https://www.cloudflare.com/ko-kr/learning/dns/what-is-dns/)
- [ICANN: DNS 기초](https://www.icann.org/resources/pages/dns-basics-2020-03-11-ko)
