# 자바 프로그램이 실행되는 흐름

## 1. 한 줄 정의
자바 프로그램은 .java 파일이 javac로 컴파일되어 .class 바이트 코드로 변환되고, JVM의 클래스 로더가 이를 메모리에 로드한 후, 실행 엔진이 인터프리터와 JIT 컴파일러를 통해 기계어로 변환하여 실행하는 과정을 거친다.

---

## 2. 자바 프로그램 실행 단계

### 2-1. 컴파일 단계 (Compilation)
- **주체**: JDK에 포함된 javac (Java Compiler)
- **입력**: .java 소스 파일
- **출력**: .class 바이트 코드 파일

```bash
# 컴파일 과정
javac HelloWorld.java  # HelloWorld.class 생성
```

```java
// HelloWorld.java (소스 코드)
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// 컴파일 후 → HelloWorld.class (바이트 코드)
// JVM이 이해할 수 있는 중간 언어로 변환됨
```

**바이트 코드란?**
- JVM이 이해할 수 있는 중간 언어
- 플랫폼 독립적 (Write Once, Run Anywhere)
- 아직 기계어가 아니므로 컴퓨터가 직접 실행 불가

### 2-2. 클래스 로딩 단계 (Class Loading)
- **주체**: 클래스 로더 (Class Loader)
- **역할**: 바이트 코드를 JVM 메모리에 동적으로 로드
- **저장 위치**: Method Area (메서드 영역)

```java
// 클래스가 로드되는 시점 예시
public class Example {
    // 1. 인스턴스 생성 시
    MyClass obj = new MyClass();  // MyClass 로드

    // 2. static 메서드 호출 시
    Math.max(10, 20);  // Math 클래스 로드

    // 3. static 변수 사용 시
    System.out.println();  // System 클래스 로드

    // 4. static 변수 할당 시
    MyClass.staticVar = 100;  // MyClass 로드
}
```

**동적 로딩이란?**
- 프로그램 시작 시 모든 클래스를 로드하지 않음
- 런타임에 필요한 클래스만 로드
- 메모리 효율성 향상

#### 2-2-1. 로딩 (Loading)
- .class 파일을 읽어서 JVM 메모리(Method Area)에 로드
- 클래스의 메타데이터(클래스명, 메서드 정보 등) 저장

```
.class 파일 → 클래스 로더 → Method Area
```

#### 2-2-2. 링킹 (Linking)
로드된 클래스를 실행 가능하도록 준비하는 3단계 과정

**1) Verification (검증)**
- .class 파일의 구조적 정합성 확인
- 바이트 코드가 JVM 명세를 준수하는지 검사

```
// 검증 예시
- 파일 포맷이 올바른가?
- final 클래스를 상속하지 않았는가?
- 메서드 시그니처가 올바른가?
```

**2) Preparation (준비)**
- static 변수를 메모리에 할당
- 기본값으로 초기화 (사용자 지정값 X)

```java
public class Example {
    static int count = 100;  // Preparation: 0으로 초기화
    static String name = "Java";  // Preparation: null로 초기화
}
```

**3) Resolution (해석)**
- 심볼릭 레퍼런스를 실제 메모리 레퍼런스로 변환

```java
// 심볼릭 레퍼런스 → 실제 메모리 주소
MyClass obj = new MyClass();
// "MyClass"라는 이름 → 실제 MyClass가 저장된 메모리 주소
```

#### 2-2-3. 초기화 (Initialization)
- static 변수를 사용자 지정값으로 초기화
- static 블록 실행

```java
public class Example {
    static int count = 100;  // 이제 100으로 초기화

    static {
        System.out.println("Static block executed");
        count = 200;
    }
}
```

### 2-3. 실행 단계 (Execution)
- **주체**: 실행 엔진 (Execution Engine)
- **역할**: 바이트 코드를 기계어로 변환하여 실행
- **방식**: 인터프리터 + JIT 컴파일러

#### 2-3-1. 인터프리터 (Interpreter)
- 바이트 코드를 한 줄씩 읽어서 실행
- 초기 실행 속도가 빠름
- 반복 실행 시 매번 해석해야 하므로 성능 저하

```
바이트 코드 → 인터프리터 → 기계어 (한 줄씩)
```

```java
// 인터프리터 방식 예시
for (int i = 0; i < 1000; i++) {
    System.out.println(i);  // 매번 바이트 코드를 해석
}
```

**장점**: 즉시 실행 가능, 빠른 시작
**단점**: 반복 실행 시 비효율적

#### 2-3-2. JIT 컴파일러 (Just-In-Time Compiler)
- 자주 실행되는 코드(Hotspot)를 감지
- 해당 메서드 전체를 네이티브 코드로 변환
- 변환된 코드를 캐싱하여 재사용

```
핫스팟 감지 → JIT 컴파일 → 네이티브 코드 → 캐싱
```

```java
// JIT 컴파일 대상 예시
public int calculate(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += i;  // 반복 실행 → 핫스팟 감지 → JIT 컴파일
    }
    return sum;
}
```

**장점**: 반복 실행 시 매우 빠름
**단점**: 컴파일 과정에 오버헤드 발생

---

## 3. 인터프리터와 JIT 컴파일러를 함께 사용하는 이유

### 3-1. 초기 JVM의 한계
- 초기 JVM은 인터프리터만 사용
- 매번 바이트 코드를 해석하여 성능 저하

### 3-2. JIT 컴파일러 도입 배경
- 반복 실행되는 코드의 성능 최적화 필요
- 네이티브 코드로 변환하여 캐싱

### 3-3. 하이브리드 방식의 장점

| 방식 | 초기 실행 | 반복 실행 | 메모리 |
|------|----------|----------|--------|
| **인터프리터** | 빠름 | 느림 | 적음 |
| **JIT 컴파일러** | 느림 (컴파일 시간) | 매우 빠름 | 많음 (캐싱) |
| **하이브리드** | 빠름 | 빠름 | 균형 |

```java
// 하이브리드 방식 예시
public class Example {
    public static void main(String[] args) {
        // 1. 초기 실행: 인터프리터 사용
        System.out.println("Start");

        // 2. 반복 실행: JIT 컴파일러가 핫스팟 감지
        for (int i = 0; i < 10000; i++) {
            calculate(i);  // 네이티브 코드로 변환 후 캐싱
        }
    }

    static int calculate(int n) {
        return n * n;
    }
}
```

**실행 흐름**:
1. 처음에는 인터프리터가 바이트 코드를 한 줄씩 실행
2. `calculate()` 메서드가 반복 실행됨을 감지
3. JIT 컴파일러가 `calculate()` 전체를 네이티브 코드로 변환
4. 이후 `calculate()` 호출 시 캐싱된 네이티브 코드 사용

---

## 4. 전체 실행 흐름 요약

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 컴파일 단계 (개발자 → javac)                              │
│    .java 파일 → javac → .class 바이트 코드                   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 클래스 로딩 단계 (JVM 클래스 로더)                         │
│    ① 로딩: .class → Method Area                             │
│    ② 링킹: 검증 → 준비 → 해석                                │
│    ③ 초기화: static 변수/블록 실행                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 실행 단계 (JVM 실행 엔진)                                  │
│    ① 인터프리터: 바이트 코드 → 기계어 (한 줄씩)               │
│    ② JIT 컴파일러: 핫스팟 → 네이티브 코드 (캐싱)              │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. 백엔드 개발자 관점의 중요성

### 5-1. 성능 최적화
- **핫스팟 인식**: 반복 실행되는 코드 최적화
- **클래스 로딩**: 지연 로딩으로 메모리 효율화
- **JIT 워밍업**: 서버 시작 후 성능이 점진적으로 향상되는 이유

```java
// 실무 예시: 캐싱 전략
public class UserService {
    // 자주 호출되는 메서드 → JIT 최적화 대상
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}
```

### 5-2. 메모리 관리
- **Method Area**: 클래스 메타데이터 저장
- **동적 로딩**: 필요한 클래스만 로드
- **GC 관리**: 사용되지 않는 클래스 언로드

### 5-3. 배포 및 운영
- **바이트 코드 검증**: 런타임 오류 방지
- **플랫폼 독립성**: WORA (Write Once, Run Anywhere)
- **컨테이너 환경**: Docker 등에서 JVM 최적화

---

## 6. 핵심 요약

### 6-1. 실행 흐름 3단계

| 단계 | 주체 | 입력 | 출력 | 역할 |
|------|------|------|------|------|
| **컴파일** | javac | .java | .class | 바이트 코드 생성 |
| **로딩** | 클래스 로더 | .class | 메모리 | Method Area에 로드 |
| **실행** | 실행 엔진 | 바이트 코드 | 기계어 | 인터프리터 + JIT |

### 6-2. 클래스 로딩 3단계

1. **로딩**: .class → Method Area
2. **링킹**: 검증 → 준비 → 해석
3. **초기화**: static 변수/블록 실행

### 6-3. 실행 방식 비교

| 특성 | 인터프리터 | JIT 컴파일러 |
|------|-----------|-------------|
| **실행 방식** | 한 줄씩 해석 | 전체 메서드 컴파일 |
| **초기 속도** | 빠름 | 느림 (컴파일 시간) |
| **반복 속도** | 느림 | 매우 빠름 |
| **메모리** | 적음 | 많음 (캐싱) |
| **사용 시점** | 첫 실행 | 핫스팟 감지 후 |

### 6-4. 실무 팁

- **클래스 로딩 최적화**: 필요한 시점에만 클래스 로드
- **JIT 워밍업**: 서버 시작 후 트래픽 증가 전 워밍업 수행
- **메모리 모니터링**: Method Area 크기 조정 (`-XX:MaxMetaspaceSize`)
- **성능 튜닝**: JIT 컴파일 임계값 조정 (`-XX:CompileThreshold`)

```bash
# JVM 옵션 예시
java -XX:MaxMetaspaceSize=256m \
     -XX:CompileThreshold=10000 \
     -jar myapp.jar
```

### 6-5. 면접 포인트

1. **동적 로딩**: 런타임에 필요한 클래스만 로드 → 메모리 효율
2. **링킹 단계**: 검증, 준비, 해석을 통해 안전한 실행 보장
3. **하이브리드 실행**: 인터프리터(빠른 시작) + JIT(빠른 반복)
4. **플랫폼 독립성**: 바이트 코드 → JVM → 기계어
