# 동시성 문제 해결을 위한 조건

## 경쟁 상태(Race Condition)란?

경쟁 상태는 **여러 스레드가 하나의 공유 자원에 동시에 접근**할 때, **스레드 실행 순서에 따라 결과가 달라지는 문제**를 말합니다.  


이런 현상은 **동시성 프로그래밍에서 매우 흔하게 발생**하며, 의도치 않은 버그를 유발합니다.

---

## 경쟁 상태를 해결하려면?

**원자성(Atomicity)**과 **가시성(Visibility)** 두 가지 조건이 반드시 보장되어야 합니다.

---

## 원자성 (Atomicity)

- 어떤 연산이 더 이상 나눌 수 없는 **하나의 단위로 완전하게 수행되는 성질**입니다.
- 예시: `i++`는 단일 연산처럼 보이지만, 실제로는 세 단계로 나뉩니다:
    1. 변수의 현재 값을 읽음
    2. 값을 1 증가시킴
    3. 결과를 다시 변수에 저장함

- 이 사이에 **다른 스레드가 개입하면 잘못된 결과가 나올 수 있습니다.**

### 예시 문제 상황
두 개의 스레드가 동시에 `i++`를 수행하는 경우:
- 스레드 A와 B가 같은 시점에 i 값을 읽고,
- 둘 다 `i + 1` 계산 후 저장하면,
- 실제로는 두 번 증가해야 할 i가 한 번만 증가할 수 있습니다.

---

## 👁 가시성 (Visibility)

- 한 스레드가 변경한 값이 **다른 스레드에서 즉시 보이는 성질**을 의미합니다.
- 현대 CPU는 **각 코어마다 캐시**를 갖고 있어,
    - 스레드 A가 값을 변경해도
    - 스레드 B는 변경 전 값을 볼 수 있습니다.

### 예시 문제 상황
- 스레드 A가 공유 변수의 값을 수정했지만,
- 그 값이 메인 메모리에 즉시 반영되지 않으면
- 스레드 B는 **오래된 값**을 읽게 됩니다.

---

## 🛠 자바에서의 해결 방법

### 원자성과 가시성 모두 보장

- `synchronized` 키워드
- `java.util.concurrent`의 `ReentrantLock`
- `AtomicInteger`, `AtomicBoolean` 등 **CAS 기반 Atomic 클래스**
- `ConcurrentHashMap` 등 **동시성 컬렉션**

### 👁 가시성만 보장

- `volatile` 키워드
    - 해당 변수는 **항상 메인 메모리에서 읽고 씁니다.**
    - 단, 연산이 복합적인 경우에는 **원자성이 보장되지 않기 때문에 주의**해야 합니다.
    - 보통 **읽기 전용 공유 변수**에서 유용하게 사용됩니다.

---

## 정리

| 개념     | 설명                                             | 해결 방법 예시                                |
|--------|------------------------------------------------|-------------------------------------------|
| 원자성  | 연산이 중간에 끊기지 않고 완전하게 수행됨                  | synchronized, Atomic 클래스, Lock 등     |
| 가시성  | 한 스레드의 변경 사항이 다른 스레드에도 즉시 반영됨         | volatile, synchronized, Lock 등           |

---

