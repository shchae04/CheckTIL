# 데이터베이스 인덱스의 동작원리

## 1. 인덱스(Index)란?
데이터베이스 인덱스는 **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**입니다. 인덱스는 책의 색인과 유사하게, 데이터베이스에서 특정 데이터를 빠르게 찾을 수 있도록 도와줍니다. 인덱스가 없다면 데이터베이스는 테이블의 모든 행을 검사해야 하는 **전체 테이블 스캔(Full Table Scan)**을 수행해야 합니다.

## 2. 인덱스의 필요성
- **검색 성능 향상**: 대용량 데이터에서 특정 레코드를 빠르게 찾을 수 있음
- **정렬 비용 감소**: 인덱스가 이미 정렬되어 있어 ORDER BY 연산의 비용 감소
- **고유성 보장**: 고유 인덱스를 통해 중복 데이터 방지 가능

## 3. 인덱스의 내부 구조와 동작 원리

### B-Tree 인덱스
가장 널리 사용되는 인덱스 자료구조로, 대부분의 RDBMS에서 기본 인덱스 구조로 채택하고 있습니다.

- **균형 트리(Balanced Tree)** 구조로, 모든 리프 노드가 같은 레벨에 위치
- **노드 구성**: 루트 노드, 내부 노드, 리프 노드로 구성
- **각 노드**: 키(Key)와 포인터(Pointer)의 쌍으로 구성

**B-Tree 인덱스 검색 과정**:
1. 루트 노드에서 시작하여 검색 값과 키를 비교
2. 비교 결과에 따라 적절한 자식 노드로 이동
3. 리프 노드에 도달할 때까지 과정 반복
4. 리프 노드에서 실제 데이터 레코드를 가리키는 포인터를 통해 데이터 접근

![B-Tree 구조 예시](assets/images/b-tree-index.png)

### B+Tree 인덱스
B-Tree의 변형으로, 모든 키가 리프 노드에 저장되며 리프 노드끼리 연결 리스트로 연결되어 있습니다.

- **모든 데이터는 리프 노드에만 저장**
- **리프 노드는 연결 리스트로 연결**되어 순차 접근이 용이
- 범위 검색에 더 효율적

### 해시 인덱스
해시 함수를 사용하여 키를 해시 값으로 변환하고, 이 값을 기반으로 데이터를 찾는 구조입니다.

- **등가 검색(=)에 최적화**되어 있음
- **범위 검색에는 비효율적**
- 메모리 기반 데이터베이스에서 주로 사용

## 4. 인덱스 동작 예시

### 인덱스가 없는 경우 (Full Table Scan)
```sql
SELECT * FROM employees WHERE last_name = 'Smith';
```
- 데이터베이스는 employees 테이블의 모든 행을 검사
- 시간 복잡도: O(n) (n은 테이블의 행 수)

### 인덱스가 있는 경우
```sql
-- last_name에 인덱스가 생성된 경우
CREATE INDEX idx_last_name ON employees(last_name);
SELECT * FROM employees WHERE last_name = 'Smith';
```
- B-Tree 인덱스를 통해 'Smith'를 빠르게 찾음
- 시간 복잡도: O(log n)

## 5. 인덱스 종류

### 클러스터형 인덱스 (Clustered Index)
- **테이블당 하나만 생성 가능**
- **데이터 페이지 자체가 인덱스 키 순서로 정렬**됨
- 일반적으로 기본 키(Primary Key)에 자동 생성

### 비클러스터형 인덱스 (Non-Clustered Index)
- **테이블당 여러 개 생성 가능**
- **별도의 페이지에 인덱스 정보 저장**
- 인덱스 페이지에서 실제 데이터 페이지로의 포인터를 가짐

### 복합 인덱스 (Composite Index)
- **두 개 이상의 컬럼으로 구성된 인덱스**
- 컬럼 순서가 중요 (왼쪽 컬럼부터 사용해야 효율적)

### 함수 기반 인덱스 (Function-Based Index)
- **컬럼에 함수를 적용한 결과에 대한 인덱스**
- 함수를 포함한 WHERE 절에서 효과적

## 6. 인덱스 사용 시 고려사항

### 인덱스의 장점
- **검색 속도 향상**
- **정렬 및 그룹화 연산 성능 향상**
- **테이블 조인 성능 향상**

### 인덱스의 단점
- **추가 저장 공간 필요**
- **데이터 변경 작업(INSERT, UPDATE, DELETE)시 성능 저하**
- **인덱스 관리 오버헤드**

### 인덱스 생성이 효과적인 경우
- **카디널리티(Cardinality)가 높은 컬럼** (고유한 값이 많은 컬럼)
- **WHERE 절에서 자주 사용되는 컬럼**
- **JOIN에 자주 사용되는 컬럼**
- **ORDER BY, GROUP BY에 자주 사용되는 컬럼**

### 인덱스가 비효율적인 경우
- **카디널리티가 낮은 컬럼** (예: 성별, 상태 코드 등)
- **데이터 변경이 매우 빈번한 테이블**
- **테이블의 행 수가 적은 경우**

## 7. 인덱스 튜닝 기법

### 인덱스 커버링 (Index Covering)
- 쿼리에 필요한 모든 데이터가 인덱스에 포함되어 있어 테이블 접근 없이 인덱스만으로 쿼리 처리
- 예: `SELECT col1, col2 FROM table WHERE col1 = 'value'` (col1, col2에 복합 인덱스가 있는 경우)

### 인덱스 스캔 방식
- **인덱스 탐색(Index Seek)**: 특정 값을 찾는 경우 (WHERE col = 'value')
- **인덱스 스캔(Index Scan)**: 범위 검색의 경우 (WHERE col BETWEEN 10 AND 20)
- **인덱스 스킵 스캔(Index Skip Scan)**: 복합 인덱스에서 첫 번째 컬럼을 건너뛰고 사용

## 8. 결론
데이터베이스 인덱스는 **대용량 데이터에서 검색 성능을 크게 향상**시키는 중요한 기술입니다. 그러나 모든 컬럼에 무분별하게 인덱스를 생성하는 것은 오히려 성능 저하를 가져올 수 있습니다. 따라서 **데이터의 특성과 쿼리 패턴을 고려하여 적절한 인덱스 전략을 수립**하는 것이 중요합니다. 인덱스는 읽기 작업에 최적화되어 있으므로, 읽기와 쓰기 작업의 비율을 고려하여 인덱스 설계를 해야 합니다.