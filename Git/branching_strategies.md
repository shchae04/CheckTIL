# Git 브랜치 전략 정리 (Git Flow, GitHub Flow, GitLab Flow, Trunk-Based)

## 왜 브랜치 전략이 필요할까?
- 팀의 협업 방식, 배포 빈도, 위험 관리 수준에 따라 브랜치를 운영하는 방법이 달라집니다.
- 명확한 전략을 가지면 충돌을 줄이고, 배포 안정성을 높이며, 리뷰/릴리즈 흐름을 표준화할 수 있습니다.

## 공통 용어
- main/master: 프로덕션 기준이 되는 기본 브랜치
- develop: 개발 통합 브랜치 (Git Flow에서 사용)
- feature: 기능 개발 브랜치
- release: 릴리즈 준비 브랜치
- hotfix: 프로덕션 긴급 수정 브랜치

---

## 1) Git Flow
"개발이 활발하고 정기 릴리즈를 하는 팀"에서 전통적으로 많이 사용.

### 브랜치 구성과 흐름
- 영구 브랜치: main, develop
- 보조 브랜치: feature/*, release/*, hotfix/*
- 기본 흐름:
  1. feature/이슈번호 또는 이름 으로 분기 → 개발
  2. develop으로 PR/MR → 통합
  3. 릴리즈 시점에 release/x.y.z 브랜치 생성 → 안정화/버그픽스
  4. release를 main에 병합(태그 부여) + develop에도 병합
  5. 긴급 이슈는 hotfix/x.y.z로 main에서 분기 → main과 develop에 모두 병합

### 장점
- 역할이 분리되어 릴리즈 안정화가 용이
- 긴급 수정(hotfix) 경로가 명확

### 단점
- 브랜치가 많아 복잡하고, 동기화 비용 높음
- 배포가 잦은 팀에는 무겁게 느껴질 수 있음

### 적합한 경우
- 여러 기능을 병렬로 개발하고, 정기적/배치형 릴리즈를 수행하는 중대형 팀

### 예시 명령
```bash
# 기능 시작
git checkout -b feature/123-add-login develop
# 기능 완료 후 통합
git push -u origin feature/123-add-login
# → PR을 develop으로
```

---

## 2) GitHub Flow
"CD(Continuous Deployment) 또는 잦은 배포"를 하는 팀에서 간결하게 쓰는 전략.

### 브랜치 구성과 흐름
- 영구 브랜치: main (단일)
- 작업은 항상 main에서 짧게 분기: feature/ 또는 topic 브랜치
- 작은 단위로 PR → 리뷰/검증(CI) → main으로 병합 → 곧바로 배포

### 장점
- 단순하고 가볍다
- 짧은 사이클, 빠른 배포에 적합

### 단점
- 릴리즈 준비용 별도 브랜치가 없어 안정화 기간 관리가 어려울 수 있음
- 프로덕션 안정성은 강한 테스트/CI 문화에 의존

### 적합한 경우
- 배포 자동화가 잘 되어 있고, 기능을 작은 단위로 자주 릴리즈하는 팀

### 예시 명령
```bash
git checkout -b feat/login main
git push -u origin feat/login
# → PR을 main으로, 리뷰 후 머지
```

---

## 3) GitLab Flow
"환경(환경별 브랜치) 또는 이슈 트래킹과의 연계"를 강조하는 유연한 전략.

### 대표적인 두 가지 패턴
1) 환경 브랜치 패턴
- main → pre-prod/staging → production 같은 환경별 브랜치 운영
- 기능 브랜치는 main에 머지 후, 환경 브랜치로 프로모션(체리픽/머지)

2) 이슈 기반 브랜치 + 릴리즈 태그/브랜치
- 이슈/기능 브랜치를 기본 브랜치에 머지하고, 특정 시점에 태그/릴리즈 브랜치를 사용해 배포 관리

### 장점
- 환경별 승인/배포 흐름을 명확히 표현 가능
- 상황에 맞춰 GitHub Flow와 Git Flow의 장점을 혼합

### 단점
- 팀 합의가 중요하며, 설계에 따라 복잡해질 수 있음

### 적합한 경우
- 스테이징/프로덕션 등 다중 환경 운영, 승인 게이트가 필요한 팀

### 예시 명령
```bash
# 스테이징 프로모션(예시: 체리픽)
git checkout staging
git cherry-pick <commit_sha>
```

---

## 4) Trunk-Based Development (Trunk 기반 개발)
"트렁크(주 브랜치)로 매우 자주, 아주 작은 변경을 머지"하는 방식.

### 브랜치 구성과 흐름
- trunk(main) 단일 중심, 짧은-lived 브랜치 (몇 시간~하루 단위)
- Feature flags(기능 토글)로 미완성 코드를 숨긴 채 빈번히 통합

### 장점
- 병합 지옥 방지(일찍/자주 통합)
- CD 파이프라인과 찰떡궁합, 리드타임 단축

### 단점
- 강력한 테스트 자동화/코드리뷰 문화가 필수
- 기능 토글/런타임 스위치 관리 비용

### 적합한 경우
- 고빈도 배포, 성숙한 CI/CD, 높은 자동화/관측성 갖춘 팀

### 예시 명령
```bash
git checkout -b wip/refactor-auth main
# 작은 단위 작업 후 바로 PR로 trunk에 통합
```

---

## 5) Release Flow (단순화된 릴리즈 브랜치 운영)
- main은 항상 최신 상태 유지, 릴리즈 순간에 release/x.y.z 브랜치 생성하여 QA/버그픽스 후 태그로 마감.
- 이후 변경은 main과 release 브랜치 양쪽에 필요한 만큼 체리픽/머지.

### 장단점 요약
- GitHub Flow보다 릴리즈 안정화 기간을 두기 쉬움
- Git Flow보다 간결

### 적합한 경우
- 빈번한 배포도 하지만, 버전 단위 안정화 윈도우가 필요한 제품팀

---

## 전략 선택 가이드
- 배포 빈도
  - 매우 잦음/작은 변경 단위: Trunk-Based, GitHub Flow
  - 주기적/묶음형 릴리즈: Git Flow, Release Flow
- 팀 규모/복잡도
  - 대규모/다기능 병렬 개발: Git Flow, GitLab Flow(환경 기반)
  - 소/중규모, 자동화 성숙: GitHub Flow, Trunk-Based
- 환경/승인 프로세스
  - 환경별 검증/승인 필요: GitLab Flow(환경 브랜치), Release Flow
- 조직 문화/도구 성숙도
  - 강한 CI/CD/테스트/Feature Flags가 가능하면 간결한 전략이 유리

---

## 빠른 비교 요약
- Git Flow: 규범적·안정적, 하지만 무거움
- GitHub Flow: 단순·빠름, 테스트/자동화가 핵심
- GitLab Flow: 환경/프로세스 표현에 유연
- Trunk-Based: 극단적 단순·초고빈도 통합, 토글/자동화 필수
- Release Flow: 릴리즈 안정화 창구 제공, 비교적 간단

---

## 실무 팁 (전략 공통)
1. 보호 브랜치 설정
   - main/develop/staging 등에 강제 리뷰, 상태 체크(CI), 직접 푸시 금지
2. PR/MR 규칙
   - 작은 단위, 명확한 설명/체크리스트, 템플릿 사용, 스쿼시/리베이스 정책 합의
3. 버저닝/태깅
   - SemVer(예: v1.4.2) 사용, 릴리즈 노트 자동화
4. 병합 전략
   - 스쿼시: 이력 간결, 리베이스: 선형 이력, 머지커밋: 컨텍스트 보존
5. Hotfix 처리
   - 프로덕션에서 분기 → 수정 → 프로덕션과 개발 라인에 모두 반영
6. 장기 브랜치 지양
   - 긴 수명의 브랜치는 충돌/파편화의 원인, "작게/자주"를 지향

---

## 마무리
팀의 배포/검증 문화, 자동화 수준에 맞춰 전략을 선택하세요. 시작은 단순하게 하고, 필요에 따라 환경 브랜치나 릴리즈 브랜치를 보완적으로 도입하면 운영 복잡도를 낮추면서도 안정성을 확보할 수 있습니다.
